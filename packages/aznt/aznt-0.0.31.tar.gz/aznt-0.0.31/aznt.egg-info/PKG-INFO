Metadata-Version: 2.1
Name: aznt
Version: 0.0.31
Summary: From A to Z Number Theory
Author-email: "Adrian Zapa≈Ça, MSc" <adrian.zapala@outlook.com>
Keywords: aznt,numbers,number theory,primes,prime numbers,math
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Education
Classifier: Intended Audience :: End Users/Desktop
Classifier: Intended Audience :: Information Technology
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3.11
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Scientific/Engineering :: Information Analysis
Classifier: Topic :: Scientific/Engineering :: Mathematics
Classifier: Topic :: Security :: Cryptography
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires-Python: >=3.11
Description-Content-Type: text/markdown
License-File: LICENCE.txt

![Python Version](https://img.shields.io/badge/python-3.11-blue/)
![aznt version](https://img.shields.io/badge/aznt-0.0.31-green)
![Beta version](https://img.shields.io/badge/beta-ver.-green)

# `aznt` - From A to Z Number Theory

* Number Theory library for Python with prime numbers.
* **Important:** requires Python >= 3.11.
* You can pass to author's GitHub at
[adrianzapala.github.io](https://adrianzapala.github.io/).

# Install

```python
pip install aznt
```

# Imports

The package `aznt` includes two modules: `azntnumbers` 
and `azntprimes`.<br>
**<span style="color: coral">Examples</span>**

```python
import aznt.azntnumbers as azntn
```

# Usage: `azntnumbers` module functions

## `factorization(n)`

Returns prime factors of a number from a function argument.<br>
Time complexity: `O(n/2)`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> factorization(8)
[2, 2, 2]
>>> factorization(1123243)
[11, 11, 9283]
>>> factorization(20570952)
[2, 2, 2, 3, 17, 127, 397]
```

## `dividers_naive(n)`

Returns divisors of a number from a function argument. It returns 
a list of these divisors.<br>
Time complexity: `O(n)`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> dividers_naive(1123243)
[1, 11, 121, 9283, 102113, 1123243]
>>> dividers_naive(20570952)
[1, 2, 3, 4, 6, 8, 12, 17, 24, 34, 51, 68, 102, 127, 136, 204, 254, 381, 397, 408, 508, 762, 794, 1016, 1191, 1524, 1588, 2159, 2382, 3048, 3176, 4318, 4764, 6477, 6749, 8636, 9528, 12954, 13498, 17272, 20247, 25908, 26996, 40494, 50419, 51816, 53992, 80988, 100838, 151257, 161976, 201676, 302514, 403352, 605028, 857123, 1210056, 1714246, 2571369, 3428492, 5142738, 6856984, 10285476, 20570952]
```

## `dividers_opt(n)`

This function calculates divisors in pairs, which multiplication product creates 
a number from function argument. If the argument is default (`pairs=False`) 
and also if the numbers from these pairs are different it puts these pairs on the 
list and then sort list (if the numbers are equal, it's placing only one number on the list). 
Alternatively, if the argument is `True`  it join pairs of divisors (may be 
equal) into tuples and then append them into a list.<br>
This function works pretty much faster than `dividers_naive()` function.<br>
Time complexity: `O(sqrt(n)`.<br>
**<span style="color: coral">Examples</span>**
```python
dividers_opt(100)
[1, 2, 4, 5, 10, 20, 25, 50, 100]
dividers_opt(100, pairs=True)
[(1, 100), (2, 50), (4, 25), (5, 20), (10, 10)]
```

## `tau(n)`

Counts the number of divisors of an integer (including 1 and the number itself).<br>
Time complexity: `O(sqrt(n))`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> tau(6)
4
>>> tau(4356)
27
>>> tau(12499674)
16
```

## `sigma(n)`

Returns the sum of divisors of an integer 
(including 1 and the number itself).<br>
Time complexity: `O(sqrt(n)))`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> sigma(3)
4
>>> sigma(343532)
687120
```

## `s(n)`

Returns the sum of proper divisors of an integer 
(excluding `n` itself).<br>
Time complexity: `O(sqrt(n)))`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> s(3)
1
>>> s(4438)
3194
```

## `gcd_mod(a, b)`

Returns Greatest Common Divisor (GCD) of two positive integers using Euclidean algorithm 
with division.<br>
Time complexity: `O(log n))`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> gcd_mod(36, 882)
18
>>> gcd_mod(363, 1287)
33
>>> gcd_mod(23, 3456)
1
>>> gcd_mod(484, 56)
4
```

## `gcd_subtract(a, b)`

Returns Greatest Common Divisor (GCD) of two positive integers using Euclidean algorithm 
with subtraction.<br>
Time complexity: `O(n))`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> gcd_subtract(36, 882)
18
>>> gcd_subtract(363, 1287)
33
>>> gcd_subtract(23, 3456)
1
>>> gcd_subtract(484, 56)
4
```

## `lcm(a, b)`

Returns Lowest Common Multiple (LCM) of two positive integers.<br>
Time complexity: `O(log n))`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> lcm(36, 882)
1764
>>> lcm(363, 1287)
14157
>>> lcm(23, 3456)
79488
>>> lcm(484, 56)
6776
```

## `is_gcd_eq_1(n, floor, ceil)`

Returns a tuple. First
element of a tuple is a quantity of pairs of numbers which
are relatively prime to themselves, the second element is a density of them and 
the third element is a list of nested lists of them.
All pairs are randomly generated from `floor`
to `ceil` of numbers range (`n`). Based on that a variety of different 
outputs can be possible for the same parameters.<br>
Time complexity: `O(n log n))`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> is_gcd_eq_1(25, 100, 10000)
(15, 0.6, [[1470, 8779], [8447, 5117], [7852, 5597], [8111, 7225], [5375, 6721], [9191, 4239], [7101, 6361], [1099, 211], [7036, 9515], [5281, 7212], [948, 2471], [3451, 4541], [3896, 9463], [8006, 845], [4448, 4803]])
>>> is_gcd_eq_1(25, 100, 10000)
(13, 0.52, [[7271, 5402], [9505, 5791], [8608, 1811], [6017, 9782], [1784, 3439], [8135, 9444], [3979, 9078], [2849, 2677], [888, 8171], [6399, 6145], [6647, 3679], [3697, 7051], [557, 553]])
```

## `totient(n)`

Returns Euler's totient function (phi) which counts the positive integers up to 
a given integer `n` that are relatively prime to `n`.<br>
Time complexity: `O(log n))`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> totient(4)
2
>>> totient(24)
8
>>> totient(424235)
253440
```

## `pnt(n)`

Returns the asymptotic distribution of the prime numbers among 
the positive integers.<br>
Time complexity: `O(log n)`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> pnt(1000)
144.76482730108395 // Real value: 168
>>> pnt(1000000)
72382.41365054197 // Real value: 78498
```

## `basel_problem(max, n=2)`

Returns precise summation of the reciprocals of the squares of the 
natural numbers, i.e. the precise sum of the infinite series. 
The sum of the series is approximately 
equal to 1.644934 (pi^2 / 6 for `n` = 2).<br>
Time complexity: `O(n)`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> basel_problem(345567)
1.6449311730576142
>>> basel_problem(2568, n=4)
1.0823232336914694
```

## `is_mersenne(m)`

Check if a number is Mersenne number, M = 2^n - 1 (prime or composite). Returns a four-element tuple. First element is boolean value - `True` or `False`.
If `True`, then second argument is M with exponent, third is the number in exponent (scientific) notation and the last is whole number.<br>
Time complexity: `O(log n)`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> is_mersenne(0)
Argument: 0. Mersenne numbers starts from 1.
>>> is_mersenne(1)
(True, 'M1', '1.00e+00', 1)
>>> is_mersenne(2)
False
>>> is_mersenne(7)
(True, 'M3', '7.00e+00', 7)
>>> is_mersenne(100)
False
>>> is_mersenne(255)
(True, 'M8', '2.55e+02', 255)
>>> is_mersenne(511)
(True, 'M9', '5.11e+02', 511)
>>> is_mersenne(1023)
(True, 'M10', '1.02e+03', 1023)
>>> is_mersenne(604462909807314587353087)
(True, 'M79', '6.04e+23', 604462909807314587353087)
```

## `is_fermat(f)`

Check if a number is Fermat number, F = 2^2^n - 1 (prime or composite). Returns a four-element tuple. First element is boolean value - `True` or `False`.
If `True`, then second argument is F with exponent, third is the number in exponent (scientific) notation and the last is whole number.<br>
Time complexity: `O(log (log n))`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> is_fermat(-3)
Argument: -3. Fermat numbers starts from 3.
>>> is_fermat(1)
Argument: 1. Fermat numbers starts from 3.
>>> is_fermat(3)
(True, 'F0', '3.00e+00', 3)
>>> is_fermat(5)
(True, 'F1', '5.00e+00', 5)
>>> is_fermat(7)
False
>>> is_fermat(17)
(True, 'F2', '1.70e+01', 17)
>>> is_fermat(257)
(True, 'F3', '2.57e+02', 257)
>>> is_fermat(65537)
(True, 'F4', '6.55e+04', 65537)
>>> is_fermat(4294967297)
(True, 'F5', '4.29e+09', 4294967297)
>>> is_fermat(18446744073709551617)
(True, 'F6', '1.84e+19', 18446744073709551617)
>>> is_fermat(340282366920938463463374607431768211457)
(True, 'F7', '3.40e+38', 340282366920938463463374607431768211457)
>>> is_fermat(115792089237316195423570985008687907853269984665640564039457584007913129639937)
(True, 'F8', '1.16e+77', 115792089237316195423570985008687907853269984665640564039457584007913129639937)
>>> is_fermat(13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084097)
(True, 'F9', '1.34e+154', 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084097)
```
## `is_perfect(n)`

Check if a number is perfect number. If so, returns True, False otherwise.<br>
Time complexity: `O(sqrt(n)`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> is_perfect(7)
False
>>> is_perfect(8128)
True
```

## `zeta_trivial_value(s, n=10000)`

Return **trivial** (real) value of Riemann zeta function for given argument, where `s` is zeta
function argument, and `n` is number of terms in the series of zeta.<br>
Time complexity: `O(n)`.<br>
**<span style="color: coral">Examples</span>**
```python
>>> zeta_trivial_value(-49)
-1.5001733492153957e+23
>>> zeta_trivial_value(-31)
472384867.72163075
>>> zeta_trivial_value(-19)
26.45621212121214
>>> zeta_trivial_value(-15)
0.44325980392156883
>>> zeta_trivial_value(-5)
-0.003968253968253967
>>> zeta_trivial_value(-4)
0
>>> zeta_trivial_value(0)
0.5
>>> zeta_trivial_value(.1)
-0.6029256240132325
>>> zeta_trivial_value(.5)
-1.4482837427744006
>>> zeta_trivial_value(1)
None
>>> zeta_trivial_value(5)
1.0369277551433702
>>> zeta_trivial_value(33)
1.0000000001164155
>>> zeta_trivial_value(50)
1.0000000000000009
```
