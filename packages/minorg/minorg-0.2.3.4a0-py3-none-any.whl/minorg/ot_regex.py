import logging
import regex as re

from typing import Callable

from minorg import (
    MINORgError
)

CHAR_UNALIGNED = ' '
CHAR_DEL = 'd'
CHAR_INS = 'i'
CHAR_MISMATCH = 'm'
CHAR_MATCH = '.'
CHAR_GAP = 'g' ## used in MINORg off-target regex
BTOP_GAP = '-' ## used in raw btop pattern (generated by BLAST)

## TODO: figure out a way to cache expanded btop patterns when using expand_btop in _is_offtarget_aln
## TODO: test split_pattern and split_pattern_or

LEVEL = logging.INFO
def printlog(*args, **kwargs):
    if LEVEL <= logging.DEBUG:
        print(*args, **kwargs)
    return

# ## dummy test
# from minorg.blast import BlastHSP

# class Object:
#     def __init__(self):
#         return

# hsp = Object()
# query = Object()
# subject = Object()
# query.seq_len = 20
# hsp.btop = "1AG-T12-TAG1"
# hsp.hit_start = 1
# hsp.hit_end = 21
# blasthsp = BlastHSP(hsp, query, subject)
# OffTargetExpression("1m3,2g3", unaligned_as_gap = False, unaligned_as_mismatch = True)(blasthsp)
# OffTargetExpression("1m3,2g3", unaligned_as_gap = True, unaligned_as_mismatch = True)(blasthsp)
# OffTargetExpression("1m3,2g3", unaligned_as_gap = True, unaligned_as_mismatch = False)(blasthsp)
# OffTargetExpression("0g4")(blasthsp)
# OffTargetExpression("1g4")(blasthsp)
# OffTargetExpression("0g4|(2m4,0g5)")(blasthsp) # False
# OffTargetExpression("0g4|(2m4,1g5)")(blasthsp) # True

# test_ot_range = lambda rp: [1, 2, 3, 4, 5, -5, -4, -3, -2, -1][ot_range(rp)[0]:ot_range(rp)[1]]
# test_ot_range("5")
# test_ot_range("-5")
# test_ot_range("5-")
# test_ot_range("-5-")
# test_ot_range("2-4")
# test_ot_range("-2--4")

########################
##  PARSE OFF-TARGET  ##
##  PATTERN MATCHING  ##
########################

def ot_range(range_pattern):
    """
    Parses range from string and returns tuple of [start, end).
    
    Arguments:
        range_pattern (str): string of range, start and end inclusive.
            Start and end must be on same side of zero. (e.g. '-4--8', '4-8')
    
    Returns
    -------
    tuple
        Start inclusive, end exclusive range (e.g. '-4--8' -> (-4, -9); '4-8' -> (4, 9))
    
    Raises
    ------
    MINORgError
        If unable to parse the range pattern
    """
    try:
        start = re.search("^-*\d+", range_pattern).group(0)
        rvs_start = start[0] == '-'
        end_length = len(range_pattern) - len(start)
        # print("range start")
        start = int(start)
        if start == 0:
            print((f"'0' is an invalid position in range '{range_pattern}'."))
            raise MINORgError
        # print("range start:", start)
        if end_length == 0:
            # # end = start-1 if rvs else start+1
            # end = start-1 if rvs_start else start
            # start = -1 if rvs else 0
            end = None if rvs_start else start
            start = start if rvs_start else None
        elif end_length == 1 and range_pattern[-1] == '-':
            end = (start+1 if start<-1 else None) if rvs_start else None
            start = None if rvs_start else start-1
        else:
            end = re.search("(?<=-)-*\d+$", range_pattern).group(0)
            rvs_end = end[0] == '-'
            if rvs_start != rvs_end:
                print((f"Start ({start}) and end ({end}) of each off-target pattern expression"
                       " must either both be positive or both be negative."))
                raise MINORgError
            print("range end")
            end = int(end)
            if end == 0:
                print((f"'0' is an invalid position in range '{range_pattern}'."))
                raise MINORgError
            print("range end:", end)
            if rvs_end:
                start = (start+1 if start<-1 else None)
                swap = start
                start = end
                end = swap
            else:
                start = start-1
        return (start, end)
    except:
        raise MINORgError(f"Unable to parse off-target pattern range: {range_pattern}")

class OffTargetExpression:
    """
    Object that parses and evaluates MINORg off-target expression pattern.
    
    Attributes:
        pattern (str): raw string expression pattern to be parsed
            (may include additional characters outside of parsing scope (e.g. after closing parenthesis))
        f (func): function that evaluates an input based on parsed self.pattern
            (in context of MINORg, input should be a BlastHSP object; it outputs whether a gRNA hit is
            problematic)
        length (int): length of expression (excludes opening parenthesis, includes closing parenthesis)
        unaligned_as_mismatch (bool): treat unaligned position(s) as mismatch(es)
        unaligned_as_gap (bool): treat unaligned position(s) as gap(s) (specifically as insertions)
        _op (str): used by OffTargetExpression.parse to track operations (values are None, 'and', 'or')
    """
    def __init__(self, pattern, unaligned_as_mismatch = True, unaligned_as_gap = False) -> None:
        """
        Creates an OffTargetExpression object that parses a MINORg off-target pattern into a function.
        Acts like a function but also stores expression length.
        
        Arguments:
            pattern (str): MINORg off-target pattern
            unaligned_as_mismatch (bool): treat unaligned position(s) as mismatch(es) (default=True)
            unaligned_as_gap (bool): treat unaligned position(s) as gap(s) (specifically as insertions)
                (default=False).
                Note: If unaligned_as_mismatch=True AND unaligned_as_gap=True, unaligned positions will
                be double-counted.
        """
        self.pattern = pattern
        self.f = None
        self.length = None
        self.unaligned_as_mismatch = unaligned_as_mismatch
        self.unaligned_as_gap = unaligned_as_gap
        self._op = None
        self.parse()
    def __call__(self, v) -> int:
        """
        Calls self.f to evaluate expression for a given input value. Functionally identical to self.evaluate.
        
        Arguments:
            v: input value
        
        Returns
        -------
        bool
        """
        return self.f(v)
    def __len__(self) -> int:
        """
        Returns length of expression (includes closing parenthesis, excludes opening parenthesis)
        
        Returns
        -------
        int
            Length of expression
        """
        return self.length
    def evaluate(self, v) -> bool:
        """
        Calls self.f to evaluate expression for a given input value. Functionally identical to self.__call__
        
        Arguments:
            v: input value
        
        Returns
        -------
        bool
        """
        return self.f(v)
    def _and(self, new_expr):
        """
        Function that combines self.f with a new expression using AND operator and replaces self.f with
        a function that evaluates this new combination.
        
        Arguments:
            new_expr (func): function that evaluates an input and outputs either True or False
        """
        curr_f = self.f
        self.f = lambda x: curr_f(x) and new_expr(x)
    def _or(self, new_expr) -> None:
        """
        Function that combines self.f with a new expression using OR operator and replaces self.f with
        a function that evaluates this new combination.
        
        Arguments:
            new_expr (func): function that evaluates an input and outputs either True or False
        """
        curr_f = self.f
        self.f = lambda x: curr_f(x) or new_expr(x)
    def _parse_expr(self, pattern) -> Callable[[str], bool]:
        """
        Function to parse str pattern of an expression unit into function that
        returns True or False for a given input.
        
        Arguments:
            pattern (str): pattern (analogous to regex pattern)
        """
        return self._minorg_ot_expr(pattern)
    def _minorg_ot_expr(self, pattern) -> Callable[[str], bool]:
        """
        Parses expression pattern and returns function that accepts a BlastHSP object and outputs
        whether the BlastHSP hit matches the expression pattern.

        In the context of MINORg's off-target pattern, ``True`` is output for gRNA that match the pattern
        and are thus problematic.

        Arguments:
            pattern (str): MINORg off-target pattern

        Returns
        -------
        func
            Function that accepts a HSP and QueryResult object and returns ``True`` if a gRNA hit is problematic
            per the specifications of the provided pattern

        Raises
        ------
        MINORgError
            If unable to parse the pattern
        """
        try:
            n = int(re.search("^\d+", pattern).group(0))
            mismatch = CHAR_MISMATCH in pattern
            gap = CHAR_GAP in pattern
            insertion = CHAR_INS in pattern
            deletion = CHAR_DEL in pattern
            if gap and (insertion or deletion):
                self.logfile.warning( ("'i' (insertion) and 'd' (deletion) should not be used with 'g' (gap)."
                                       " 'i' and/or 'd' will be ignored.") )
                insertion = deletion = False
            r = ot_range(re.search("[-\d]+$", pattern).group(0))
            start, end = r
            rvs = any([(x is not None and x < 0) for x in r])
            printlog("n, r:", n, r)
            char_to_count = [c for c in
                             [CHAR_MISMATCH if mismatch else ''] + \
                             [CHAR_INS if insertion or gap else ''] + \
                             [CHAR_DEL if deletion or gap else '']
                             if c != '']
        except:
            raise MINORgError(f"Unable to parse off-target pattern: {pattern}")
        def helper(blasthsp):
            printlog("char to count:", char_to_count)
            printlog("range:", r)
            num = blasthsp._num_char_in_range(*char_to_count, start = start, end = end, rvs_index = rvs)
            printlog("num m/g:", num)
            num_unaligned = blasthsp._num_char_in_range(CHAR_UNALIGNED, start = start, end = end,
                                                        rvs_index = rvs)
            printlog("num unaligned:", num_unaligned)
            if mismatch and self.unaligned_as_mismatch: num += num_unaligned
            if (insertion or gap) and self.unaligned_as_gap: num += num_unaligned
            printlog("n:", n)
            return num <= n
        return helper
    def _build_expr(self, new_expr) -> None:
        """
        Calls either self._and or self._or depending on value of self._op to build
        self.f (function that combines several expressions).
        
        Arguments:
            new_expr (func): function that evaluates an input and outputs either True or False
        
        Raises
        ------
        MINORgError
            If unable to determine which operator to use
        """
        if self.f is None: self.f = new_expr
        elif self._op == "and": self._and(new_expr)
        elif self._op == "or": self._or(new_expr)
        else: raise MINORgError("self._op must be 'and' or 'or' if self.f is not None")
    def parse(self) -> None:
        """
        Function to convert str pattern into function (stored at self.f)
        that evaluates an input using the pattern.
        """
        output_expr = None
        pattern_len = len(self.pattern)
        pattern_last_index = pattern_len - 1
        start = 0
        i = 0
        while i < pattern_len:
            c = self.pattern[i]
            printlog("GEN:", start, i, c)
            ## if open bracket
            if c == '(':
                expr = OffTargetExpression(self.pattern[i+1:],
                                           unaligned_as_mismatch = self.unaligned_as_mismatch,
                                           unaligned_as_gap = self.unaligned_as_gap)
                self._build_expr(expr)
                printlog("( expr:", self.pattern[i+1:i+1+len(expr)])
                ## '1' for opening parenthesis (closing parenthesis is included in expr_len)
                start = i+1+len(expr)
                i = start
            ## if end of expression unit, process and add to 'expressions' var
            elif c == ',':
                printlog("expr AND:", self.pattern[start:i])
                if start != i:
                    expr = self._parse_expr(self.pattern[start:i])
                    self._build_expr(expr)
                self._op = "and"
                start = 1+i ## '1' for current character
                i += 1
            ## if '|' (OR)
            elif c == '|':
                printlog("expr OR:", self.pattern[start:i])
                if start != i:
                    expr = self._parse_expr(self.pattern[start:i])
                    self._build_expr(expr)
                self._op = "or"
                start = 1+i ## '1' for current character
                i += 1
            ## if close bracket
            elif c == ')':
                printlog("expr ):", self.pattern[start:i])
                expr = self._parse_expr(self.pattern[start:i])
                self._build_expr(expr)
                i += 1
                break
            ## elif last char
            elif i >= pattern_last_index:
                printlog("last expr:", self.pattern[start:pattern_len])
                expr = self._parse_expr(self.pattern[start:pattern_len])
                printlog("parsed")
                self._build_expr(expr)
                i += 1
                break
            ## else just move to next char
            else:
                i += 1
        printlog("exit")
        self.length = i
        return

# def btop_num_mismatch(btop):
#     """
#     Accepts either <btop> or <string or a tuple of expanded btop> and returns number of mismatches.
    
#     Arguments:
#         btop (str, tuple): btop pattern or expanded btop (str or tuple)
    
#     Returns
#     -------
#     int
#         Number of mismatches
#     """
#     ## expand btop if not already expanded (cuz it's tedious to count mismatches with raw btop)
#     ## OR merge into string for easier counting if is tuple
#     sbtop = to_expanded_btop_str(btop)
#     return sbtop.count(CHAR_MISMATCH)

# def btop_num_ins(btop):
#     """
#     Accepts either <btop> or <string or a tuple of expanded btop> and returns number of insertions
#     relative to subject (that is, one or more bases that is/are present in the query but not in the subject).
    
#     Arguments:
#         btop (str, tuple): btop pattern or expanded btop (str or tuple)
    
#     Returns
#     -------
#     int
#         Number of insertions
#     """
#     ## expand btop if not already expanded (cuz it's tedious to count mismatches with raw btop)
#     ## OR merge into string for easier counting if is tuple
#     sbtop = to_expanded_btop_str(btop)
#     return sbtop.count(CHAR_INS)

# def btop_num_del(btop):
#     """
#     Accepts either <btop> or <string or a tuple of expanded btop> and returns number of deletions
#     relative to subject (that is, one or more bases that is/are present in the subject but not in the query).
    
#     Arguments:
#         btop (str, tuple): btop pattern or expanded btop (str or tuple)
    
#     Returns
#     -------
#     int
#         Number of insertions
#     """
#     ## expand btop if not already expanded (cuz it's tedious to count mismatches with raw btop)
#     ## OR merge into string for easier counting if is tuple
#     sbtop = to_expanded_btop_str(btop)
#     return sbtop.count(CHAR_DEL)

# def btop_num_gap(btop):
#     """
#     Accepts either <btop> or <string or a tuple of expanded btop> and returns number of gaps.
    
#     Arguments:
#         btop (str, tuple): btop pattern or expanded btop (str or tuple)
    
#     Returns
#     -------
#     int
#         Number of gaps
#     """
#     ## expand btop if not already expanded (cuz it's tedious to count mismatches with raw btop)
#     ## OR merge into string for easier counting if is tuple
#     sbtop = to_expanded_btop_str(btop)
#     return btop_num_del(sbtop) + btop_num_ins(sbtop)

# def is_expanded_btop(btop):
#     if not isinstance(btop, str): return True
#     else: return (CHAR_MATCH in btop or CHAR_MISMATCH in btop or CHAR_DEL in btop or CHAR_INS in btop)

# def to_expanded_btop_str(btop):
#     if isinstance(btop, str):
#         ## expand btop if not already expanded
#         if not is_expanded_btop(btop): btop = str_expand_btop(btop)
#     else:
#         ## merge into string if tuple
#         btop = ''.join(btop)
#     return btop

# def tuple_expand_btop(btop, rvs_index = False):
#     """
#     Calls str_expand_btop and groups expanded btop to a tuple of characters
#     of length equal to aligned query, where:
#         '.' is a match,
#         'm' is a mismatch,
#         'i' is an insertion in the query,
#         'd' is a deletion in the query (deletion between N and N+1 will be grouped with position N+1 if rvs_index=False else N).
    
#     Arguments:
#         btop (str): btop string
#         rvs_index (bool): default=False. A deletion between positions N and N+1 will be grouped with:
#             position N+1 if rvs_index=False;
#             position N, if rvs_index=True.
    
#     Returns
#     -------
#     tuple of str
#         Expanded btop pattern
#     """
#     str_expanded = str_expand_btop(btop)
#     output = []
#     non_del = {CHAR_MATCH, CHAR_MISMATCH, CHAR_INS}
#     ## processed characters are removed from str_expanded until none are left
#     while str_expanded:
#         c = str_expanded[0]
#         if c in non_del: ## if not deletion
#             output.append(c)
#             str_expanded = str_expanded[1:]
#         elif rvs_index: ## if deletion in reversed index
#             output[-1] = output[-1] + c
#             str_expanded = str_expanded[1:]
#         else: ## if deletion in index counting up
#             output.append(str_expanded[:2])
#             str_expanded = str_expanded[2:]
#     return tuple(output)

# def str_expand_btop(btop):
#     """
#     Expands btop to a string of characters of length equal to alignment, where:
#         '.' is a match,
#         'm' is a mismatch,
#         'i' is an insertion in the query,
#         'd' is a deletion in the query.
    
#     Arguments:
#         btop (str): btop string
    
#     Returns
#     -------
#     str
#         Expanded btop pattern
#     """
#     output = ''
#     ## processed characters are removed from btop until none are left
#     while btop:
#         num = re.search('^\d+', btop)
#         if num: ## if match
#             num = num.group(0)
#             output += CHAR_MATCH*int(num)
#             btop = btop[len(num):]
#         else: ## if gap or mismatch
#             unit = btop[:2]
#             if unit[0] == BTOP_GAP: output += CHAR_DEL ## deletion in query
#             elif unit[1] == BTOP_GAP: output += CHAR_INS ## insertion in query
#             else: output += CHAR_MISMATCH ## mismatch
#             btop = btop[2:]
#     return output

def ot_expr(pattern):
    """
    Parses expression pattern and returns function that accepts a BlastHSP object and outputs
    whether the BlastHSP hit matches the expression pattern.
    
    In the context of MINORg's off-target pattern, ``True`` is output for gRNA that match the pattern
    and are thus problematic.
    
    Arguments:
        pattern (str): MINORg off-target pattern
    
    Returns
    -------
    func
        Function that accepts a HSP and QueryResult object and returns ``True`` if a gRNA hit is problematic
        per the specifications of the provided pattern
    
    Raises
    ------
    MINORgError
        If unable to parse the pattern
    """
    try:
        n = re.search("^\d+", pattern).group(0)
        mismatch = CHAR_MISMATCH in pattern
        gap = CHAR_GAP in pattern
        insertion = CHAR_INS in pattern
        deletion = CHAR_DEL in pattern
        if gap and (insertion or deletion):
            self.logfile.warning( ("'i' (insertion) and 'd' (deletion) should not be used with 'g' (gap)."
                                   " 'i' and/or 'd' will be ignored.") )
            insertion = deletion = False
        r = ot_range(re.search("[-\d]+$", pattern).group(0))
        rvs = r[0] < 0
        char_to_count = [c for c in
                         [CHAR_MISMATCH if mismatch else ''] + \
                         [CHAR_GAP if gap else ''] + \
                         [CHAR_INS if insertion else ''] + \
                         [CHAR_DEL if deletion else '']
                         if c != '']
    except:
        raise MINORgError(f"Unable to parse off-target pattern: {pattern}")
    # def helper(hsp, query_result):
    #     ## expand btop
    #     tbtop = tuple_expand_btop(hsp.btop)
    #     ## include unaligned regions as single space character
    #     full_tbtop = (' ',)*hsp.hit_start) + tbtop + ((' ',)*(query_result.seq_len-hsp.hit_end))
    #     ## extract pattern-defined range
    #     range_tbtop = tbtop[r[0]:r[1]:(-1 if rvs else 1)]
    #     ## convert to str for easier counting
    #     btop = ''.join(range_tbtop)
    #     ## count
    #     num_gap = 0 if not gap else btop_num_gap(btop)
    #     num_mismatch = 0 if not mismatch else btop_num_mismatch(btop)
    #     num_unaligned = range_tbtop.count(' ')
    #     return num_gap + num_mismatch + num_unaligned <= n
    def helper(blasthsp):
        num = blasthsp._num_char_in_range(*char_to_count, start = start, end = end, rvs_index = rvs)
        num_unaligned = blasthsp._num_char_in_range(CHAR_UNALIGNED, start = start, end = end, rvs_index = rvs)
        return num + num_unaligned <= n
    return helper

## placeholder function to test logic of split_pattern
## e.g. split_pattern("1,0,(0|1)")[1](1) -> False
## e.g. split_pattern("1,0|(0|1)")[1](1) -> True
def ot_expr(pattern):
    def helper(inpt):
        return bool(int(pattern))
    return helper

# def split_pattern_or(pattern):
#     """
#     Returns
#     -------
#     tuple
#         Of (<length of pattern (int)>, <function to evaluate pattern>), where
#         <length of pattern> includes any closing parenthesis, and
#         <function to evaluate pattern> takes in a BlastHSP object and returns True if it matches the pattern
#     """
#     expressions = []
#     pattern_len = len(pattern)
#     pattern_last_index = pattern_len - 1
#     start = 0
#     i = 0
#     while i < pattern_len:
#         c = pattern[i]
#         printlog("OR:", start, c, i)
#         ## if end of expression unit, process and add to 'expressions' var
#         if c == '|':
#             printlog("OR expr:", pattern[start:i])
#             expressions.append(ot_expr(pattern[start:i]))
#             start = 1+i ## 1 for current character
#             i = start
#         ## if ',' (AND)
#         elif c == ',':
#             expr_len, expr = split_pattern_and(pattern[start:])
#             expressions.append(expr)
#             start = i+1+expr_len ## '1' for current character
#             i = start
#         ## if open bracket
#         elif c == '(':
#             expr_len, expr = split_pattern_and(pattern[i+1:])
#             expressions.append(expr)
#             start = i+1+expr_len ## '1' for opening parenthesis (closing parenthesis is included in expr_len)
#             i = start
#         ## if close bracket
#         elif c == ')':
#             printlog("OR expr ):", pattern[start:i])
#             expressions.append(ot_expr(pattern[start:i]))
#             i += 1
#             break
#         ## elif last char
#         elif i == pattern_last_index:
#             printlog("OR expr last:", pattern[start:i+1])
#             expressions.append(ot_expr(pattern[start:i+1]))
#             i += 1
#             break
#         ## else just move to next char
#         else:
#             i += 1
#     return i, lambda blasthsp: any(map(lambda expr: expr(blasthsp), expressions))

# def split_pattern_and(pattern):
#     def strip_leading_parentheses(pattern):
#         if pattern[0] in {'(', ')'}:
#             return strip_leading_parentheses(pattern[1:])
#         return pattern
#     expressions = []
#     pattern_len = len(pattern)
#     pattern_last_index = pattern_len - 1
#     start = 0
#     i = 0
#     while i < pattern_len:
#         c = pattern[i]
#         printlog("AND:", start, c, i)
#         ## if end of expression unit, process and add to 'expressions' var
#         if c == ',':
#             printlog("AND expr:", pattern[start:i])
#             expressions.append(ot_expr(pattern[start:i]))
#             start = 1+i ## '1' for current character
#             i += 1
#         ## if '|' (OR)
#         elif c == '|':
#             expr_len, expr = split_pattern_or(pattern[start:])
#             expressions.append(expr)
#             start = i+1+expr_len ## '1' for current character
#             i = start
#         ## if open bracket
#         elif c == '(':
#             expr_len, expr = split_pattern_and(pattern[i+1:])
#             expressions.append(expr)
#             start = i+1+expr_len ## '1' for opening parenthesis (closing parenthesis is included in expr_len)
#             i = start
#         ## if close bracket
#         elif c == ')':
#             printlog("AND expr ):", pattern[start:i])
#             expressions.append(ot_expr(pattern[start:i]))
#             i += 1
#             break
#         ## elif last char
#         elif i == pattern_last_index:
#             printlog("AND expr last:", pattern[start:i+1])
#             expressions.append(ot_expr(pattern[start:i+1]))
#             i += 1
#             break
#         ## else just move to next char
#         else:
#             i += 1
#     return i, lambda blasthsp: all(map(lambda expr: expr(blasthsp), expressions))

# def split_pattern(pattern):
#     output_expr = None
#     pattern_len = len(pattern)
#     pattern_last_index = pattern_len - 1
#     start = 0
#     i = 0
#     op = "and"
#     def build_expr(new_expr, existing_expr, op):
#         if existing_expr is None: return new_expr
#         if op == "and": return lambda x: existing_expr(x) and new_expr(x)
#         elif op == "or": return lambda x: existing_expr(x) or new_expr(x)
#     while i < pattern_len:
#         c = pattern[i]
#         printlog("GEN:", start, i, c)
#         ## if open bracket
#         if c == '(':
#             expr_len, expr = split_pattern(pattern[i+1:])
#             output_expr = build_expr(expr, output_expr, op)
#             printlog("( expr:", pattern[i+1:i+1+expr_len])
#             start = i+1+expr_len ## '1' for opening parenthesis (closing parenthesis is included in expr_len)
#             i = start
#         ## if end of expression unit, process and add to 'expressions' var
#         elif c == ',':
#             printlog("expr AND:", pattern[start:i])
#             if start != i:
#                 expr = ot_expr(pattern[start:i])
#                 output_expr = build_expr(expr, output_expr, op)
#             op = "and"
#             start = 1+i ## '1' for current character
#             i += 1
#         ## if '|' (OR)
#         elif c == '|':
#             printlog("expr OR:", pattern[start:i])
#             if start != i:
#                 expr = ot_expr(pattern[start:i])
#                 output_expr = build_expr(expr, output_expr, op)
#             op = "or"
#             start = 1+i ## '1' for current character
#             i += 1
#         ## if close bracket
#         elif c == ')':
#             printlog("expr ):", pattern[start:i])
#             expr = ot_expr(pattern[start:i])
#             output_expr = build_expr(expr, output_expr, op)
#             i += 1
#             break
#         ## elif last char
#         elif i >= pattern_last_index:
#             printlog("last expr:", pattern[start:pattern_len])
#             expr = ot_expr(pattern[start:pattern_len])
#             output_expr = build_expr(expr, output_expr, op)
#             i += 1
#             break
#         ## else just move to next char
#         else:
#             i += 1
#     printlog("exit")
#     return i, output_expr
