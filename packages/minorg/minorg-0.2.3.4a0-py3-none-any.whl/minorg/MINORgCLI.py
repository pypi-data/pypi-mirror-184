## TODO: fix this empty _to_mask.fasta file. and also make it so that genes will be masked
## using sequence in complete feature range.

## imports
import os
import copy
import click
import typer
import shutil
import logging
import warnings
import itertools

from typing import Callable, Tuple, Union

from minorg import (
    _logging_level,
    __version__,
    _warning,
    MINORgWarning,
    MINORgError,
    InputFormatError,
    InvalidPath,
    InvalidFile,
    UnreadableFile
)
from minorg.MINORg import (
    MINORg,
    PathHandler,
    parse_lookup,
)
# from minorg.filter_grna import make_exclude_function as mk_excl_fn
from minorg.constants import (
    INDV_GENOMES_ALL,
    INDV_GENOMES_NONE,
    INDV_GENOMES_REF,
    REFERENCED_ALL,
    REFERENCED_NONE,
    PAM_PATTERNS
)
from minorg.parse_config import (
    Param,
    parse_multiline_multikey_sdict
)
from minorg.grna import gRNAHits
from minorg.pam import PAM
from minorg.fasta import fasta_to_dict
from minorg.functions import (
    get_count_dict,
    non_string_iter
)

LOGGING_LEVEL = _logging_level

# __version_main__ = "3.1"
# __version_full__ = "2.1"
# __version_seq__ = "2.0"
# __version_grna__ = "2.0"
# __version_filter__ = "2.0"
# __version_minimumset__ = "2.0"

warnings.showwarning = _warning

def valid_readable_file(pathname) -> str:
    """
    Check if file path is valid AND is file AND is readable.
    
    Arguments:
        pathname (str): path to file
    
    Returns
    -------
    str
        Pathname if it points to a valid readable file
    
    Raises
    ------
    InvalidPath
        If path does not exist
    InvalidFile
        If path does not point to a file
    UnreadableFile
        If file is not readable
    """
    pathname = os.path.abspath(pathname)
    if not os.path.exists(pathname):
        raise InvalidPath(pathname)
    if not os.path.isfile(pathname):
        raise InvalidFile(pathname)
    if not os.access(pathname, os.R_OK):
        raise UnreadableFile(pathname)
    return pathname

def valid_aliases(aliases, lookup, raise_error = True, message = None, param = None,
                  none_value = None, all_value = None, clear_value = None,
                  display_cmd = None, additional_message = None):
    """
    Check if alias(es) is/are valid and prints appropriate message to terminal if alias(es) is/are invalid.
    
    Also generates and raises error for invalid alias(es) if requested (i.e. raise_error=True).
    
    Arguments:
        aliases (str or list): requird, single alias (str) or multiple aliases (list)
        lookup (dict): required, lookup dictionary (fmt: {<alias>: <value associated w/ alias>})
        raise_error (bool): throw error if alias(es) is/are invalid
        message (str): optional, message to print if alias(es) is/are invalid.
            Autogenerated if not provided.
        param (:class:`minorg.parse_config.Param`): optional, used for autogeneration of message
        none_value: optional, special alias value to indicate NO alias(es) are to be looked up.
            (I.e. valid_aliases('none', {'genomeA': '/path/to/FASTA', 'genomeB': '/path/to/FASTA'}, 
            none_value = 'none') will not flag the alias ('none') as invalid 
            despite it not being in the lookup dictionary.)
        all_value: optional, special alias value to indicate ALL alias(es).
            (I.e. valid_aliases('all', {'genomeA': '/path/to/FASTA', 'genomeB': '/path/to/FASTA'}, 
            all_value = 'all') will not flag the alias ('all') as invalid 
            despite it not being in the lookup dictionary.)
        display_cmd (str): optional, CLI keyword argument for printing lookup alias-value mapping to terminal,
            used for autogeneration of message
        additional_message (str): optional, 
            additional message to append to printed message if alias(es) is/are invalid
    
    Raises
    ------
    typer.BadParameter
        If alias(es) is/are invalid AND raise_error=True
    """
    if isinstance(aliases, str): aliases = [aliases]
    ## return None without raising error if none_value is only value provided
    if none_value is not None and len(aliases) == 1 and aliases[0] == none_value: return None
    ## identify unknown aliases
    unknown = []
    for alias in aliases:
        if alias not in lookup and alias != all_value and alias != clear_value: unknown.append(alias)
    if unknown: ## if there are unmappable values (i.e. unknown aliases, generate error message)
        if (message is None and param is not None and param.description is not None):
            message1 = lambda x: ( f"Unrecognised {param.description}" + \
                                   f" {'/'.join(param.names)}:" + \
                                   f" {', '.join(sorted(x))}" )
            if display_cmd is not None:
                message2 = lambda x: ( message1(x) +
                                       (f"\nFor a list of valid {param.description}"
                                        f"{'' if param.alias_value_description is None else ' and ' + param.alias_value_description}"
                                        f", execute 'minorg {display_cmd}'." ) )
            else: message2 = lambda x: message1(x)
            message3 = lambda x: ( message2(x) +
                                   (f"\nYou may update the list of valid {param.description}"
                                    f"{'' if not param.alias_value_description else ' and ' + param.alias_value_description} by modifying the config file located at {params.config_file}"))
            if none_value is not None:
                message4 = lambda x: ( message3(x) +
                                       (f"\nNote that the default empty value '{none_value}' should not"
                                        " be used with other values.") )
            else: message4 = lambda x: message3(x)
            if additional_message is not None: message = lambda x: message4(x) + '\n' + additional_message
            else: message = message4
        error = typer.BadParameter( f"Unrecognised alias(es): {sorted(unknown)}\n"
                                    if message is None else (message(sorted(unknown)) + '\n') )
        if raise_error: raise error
        else: return None
    else: return None

class MINORgCLI (MINORg):
    """
    Parses CLI arguments and reformats them for parent MINORg object
    
    Attributes:
        keep_on_crash (bool): keep files/directories on crash
        _raw_args (Namespace): arguments parsed only by Typer
        _args (Namespace): arguments parsed by Typer and MINORgCLI
        config (str): path to config.ini file
        master_prefix (str): prefix for permanent files
        reference_set (str): path to file containing reference genome
            alias-FASTA-GFF3-genetic code-attribute modification mapping
        cluster_set (str): path to file containing cluster alias-members mapping
        genome_set (str): path to file containing query alias-FASTA mapping
        reference_aliases (dict): reference genome mapping
            ({'<alias>': ('/path/to/FASTA', '/path/to/GFF3', '<genetic code>', '<attribute modification>')})
        cluster_aliases (dict): cluster mapping ({'<cluster alias>': ('geneA', 'geneB')})
        genome_aliases (dict): query genome mapping ({'<alias>': '/path/to/FASTA'})
        gene_sets (dict): grouping of genes into separately processed sets.
            Used for separately processing each cluster if multiple are provided.
            (e.g. {'clusterA': ('geneA', 'geneB'), 'clusterB': ('geneC', geneD')})
        mask_gene_sets (dict): genes to be masked/unmasked during reference genome screening.
            ({'mask': ('geneA', 'geneB'), 'unmask': ('geneC',)})
        background_check (bool): conduct screening for off-targets in background during filtering step
        feature_check (bool): conduct screening for gRNA within feature during filtering step
        gc_check (bool): conduct screening for gRNA with acceptable GC content during filtering step
    """
    def __init__(self, config = None, keep_tmp = False, keep_on_crash = False):
        """Create a MINORgCLI object.
        
        Arguments:
            config (str): path to config.ini file
            keep_tmp (bool): retain temporary files
            keep_on_crash (bool): override default behaiour of deleting files generated during
                execution upon unexpected termination of programme; files will be moved to self.out_dir
                if specified, else will remain in temporary directory for user to retrieve manually
                
        Returns
        -------
        :class:`~minorg.MINORgCLI.MINORgCLI`
            a MINORgCLI object
        """
        from argparse import Namespace
        super().__init__(cli = True, tmp = False, keep_tmp = keep_tmp, config = config,
                         auto_update_files = False)
        self.tracebacklimit = (None if LOGGING_LEVEL <= logging.DEBUG else 0)
        self.keep_on_crash = keep_on_crash
        self._raw_args = Namespace() ## hidden from user. Stores raw args for posterity/logging
        self._cmd_args = None ## hidden from user. Stores raw command used to run MINORg
        self._cmd_params = None ## hidden from user. Stores params (cmd units that start with '-') that users
        self._args = Namespace()
        # self.minorg = MINORg(verbose = verbose, config = config, keep_tmp = keep_tmp,
        #                      keep_on_crash = keep_on_crash) ## will not have prefix, directory, and thread
        self.config = config
        self.master_prefix = None
        ## set aliases
        self.cluster_set = None
        self.reference_set = None
        self.genome_set = None
        ## aliases parsed from sets
        self.reference_aliases = {}
        self.cluster_aliases = {}
        self.genome_aliases = {}
        ## others
        self.gene_sets = {}
        self.mask_gene_sets = {}
        self.exclude_check = False
        self.background_check = True
        self.feature_check = True
        self.gc_check = True
    
    @property
    def args(self):
        """
        MINORg CLI arguments
        
        :getter: Returns arguments parsed by MINORgCLI
        :setter: Stores a copy of args at self._raw_args and sets self._args 
                 to be acted upon by MINORgCLI parsing functions
        :type: Namespace
        """
        return self._args
    @args.setter
    def args(self, args):
        self._raw_args = copy.deepcopy(args)
        self._args = args
    
    @property
    def cmd_args(self):
        """
        MINORg CLI raw command string.
        
        :getter: Returns raw command used to execute MINORg.
        :setter: Stores a copy of args at self._cmd_args and sets self._cmd_params 
                 to track which parameters were set by user and which were by default
        :type: list
        """
        return self._cmd_args
    @cmd_args.setter
    def cmd_args(self, args):
        self._cmd_args = args
        self._cmd_params = set(x for x in args if x[0] == '-')
    
    def copy_args(self, *argnames):
        """
        Copy args values to self as attributes.
        
        Arguments:
            *argnames (str): name(s) of argument(s) to copy
        """
        for argname in argnames:
            setattr(self, argname, getattr(self.args, argname))
        return
    
    def is_user_set(self, *params, a = False):
        """
        Checks if parameters was set by user or by defaule (i.e. by parse_config.py or config file)
        
        Arguments:
            *params (:class:`minorg.parse_config.Param`): parameters to check
            a (bool): whether to return True only if ALL params are set by user (default=False)
        
        Returns:
            bool: whether at least one param (a=False) or all params (a=True) is/are set by user
                at command line
        """
        def check_param(param):
            names = tuple(itertools.chain(*[name.split('/') for name in param.names]))
            output = any(name in self._cmd_params for name in names)
            # print(self._cmd_params, names, output)
            return output
        op = all if a else any
        output = op(check_param(param) for param in params)
        return output
    
    ####################
    ##  HOUSEKEEPING  ##
    ####################

    def cleanup(self):
        """
        Resolve/delete files upon unexpected termination (e.g. mid-execution termination, crash etc.)
        """
        if self.tmp and self.keep_on_crash and os.path.exists(self.tmpdir):
            self.resolve()
        if self.tmp and not self.keep_on_crash and os.path.exists(self.tmpdir):
            print(f"cleaning up {self.tmpdir}")
            shutil.rmtree(self.tmpdir, ignore_errors = True)
    
    ################################
    ##  UPDATE SUBSET_ANNOTATION  ##
    ##   TO USE SELF.GENE_SETS    ##
    ################################
    
    def subset_annotation(self, quiet = True, sort = True):
        """
        Subset annotations of all reference genomes according to self.gene_sets and self.mask_gene_sets.
        
        Reduces annotation lookup time.
        
        Arguments:
            quiet (bool): silence printing of non-essential messages
            sort (bool): sort subset data
        """
        if self.gene_sets or self.mask_gene_sets:
            self._subset_annotation(*itertools.chain(*([x for x in self.gene_sets.values()
                                                        if x is not None] +
                                                       [x for x in self.mask_gene_sets.values()
                                                        if x is not None])),
                                    quiet = quiet, preserve_order = True)
        return
    
    #####################
    ##  ALIAS OR FILE  ##
    ##     PARSERS     ##
    #####################
    
    ## alias_or_file_parser: parse val as alias if valid else parse as path
    ## alias_or_file_callback --> MINORgCLI._alias_or_file_parser
    def _alias_or_file_parser(self, val: str, lookup: dict) -> Union[str, None]:
        """
        Accepts an alias of a file path OR a file path itself and checks if the path is valid.
        
        Arguments:
            val (str): required, alias of file path OR file path
            lookup (dict): required, lookup dictionary for mapping alias to path
        
        Returns
        -------
        str
            path to file
        
        Raises
        ------
        InvalidPath
            If path does not exist
        InvalidFile
            If path does not point to a file
        UnreadableFile
            If file is not readable
        """
        mapped_val = parse_lookup(val, lookup, return_first = True)
        if mapped_val is not None: return valid_readable_file(mapped_val)
    ## make_alias_or_file_callback --> MINORgCLI._make_alias_or_file_parser
    def _make_alias_or_file_parser(self, lookup: dict, param = None) -> Callable[[str], str]:
        """
        Generate custom alias_or_file_parser for a lookup(-param)(-message) combo.
        
        Arguments:
            lookup (dict): required, lookup dictionary for mapping alias to path
            param (:class:`minorg.parse_config.Param`): optional, used for autogeneration of lookup fail message
        
        Returns
        -------
        func
            Function that accepts an alias or path and returns a path
                (either mapped from alias or returns original argument)
        """
        def parser(val):
            parsed_val = self._alias_or_file_parser(val, lookup = lookup)
            if parsed_val == val:
                ## print lookup fail message
                if param is not None:
                    print((f"Unrecognised alias passed to {'/'.join(param.names)}."
                           f" Parsing '{x}' as path."))
                else:
                    print(f"Parsing '{x}' as path.")
            return parsed_val
        return parser

    ####################
    ##  HOUSEKEEPING  ##
    ####################
    
    def version_callback(self, val: bool):
        """
        Callback for printing version to terminal. 
        Immediately after, resolve temporary directory using :meth:`MINORgCLI.cleanup` 
        and exit programme using ``typer.Exit()``.
        """
        if val:
            print(__version__)
            # print((f"MINORg version: {__version_main__}\n"
            #        f"MINORg full: {__version_full__}\n"
            #        f"MINORg seq: {__version_seq__}\n"
            #        f"MINORg grna: {__version_seq__}\n"
            #        f"MINORg filter: {__version_filter__}\n"
            #        f"MINORg minimumset: {__version_minimumset__}\n"))
            self.cleanup()
            raise typer.Exit()
    
    #####################
    ##  SET CALLBACKS  ##
    #####################
    
    def _parse_file_set(self, val: str, lookup: dict, description: str,
                        cli_lookup_arg: str, lookup_fmt: str, param: Param,
                        num_fields = None,
                        parse_key = lambda k: k, parse_value = lambda v: v) -> Tuple[str, str, dict]:
        """
        Accepts an alias/path that points to a tab-separated lookup file
        (self.reference_set, self.cluster_set, or self.genome_set) 
        and parses that lookup file into a dictionary of {<alias>: <value>}.
        
        Arguments:
            val (str): required, alias of file path OR file path
            lookup (dict): required, lookup dictionary for mapping alias to path
            description (str): required, description of values in the lookup file (e.g. 'reference genome')
            cli_lookup_arg (str): required, CLI keyword argument for printing
                lookup alias-value mapping to terminal, used for autogeneration of message
            lookup_fmt (str): required, dash-separated field names in lookup file (e.g. 'alias-FASTA')
            param (:class:`minorg.parse_config.Param`): required, for retrieval of keyword arg names
            parse_key (func): optional, function to reformat alias string
            parse_value (func): optional, function to reformat value string
            num_fields (int): optional, adds empty elements if number of fields in value < num_fields
        
        Returns
        -------
        str
            path to lookup file
        str
            absolute path to lookup file
        dict
            lookup dict parsed from lookup file
        
        Raises
        ------
        InvalidPath
            If path does not exist
        InvalidFile
            If path does not point to a file
        UnreadableFile
            If file is not readable
        InputFormatError
            If format of lookup file is incorrect
        typer.BadParameter
            If argument ``val`` does not point to a valid file
        """
        val = parse_lookup(val, lookup, return_first = True)
        if val is not None:
            if os.path.exists(os.path.abspath(val)):
                set_fname = os.path.abspath(val)
                try:
                    with open(set_fname, 'r') as f:
                        set_aliases = {parse_key(k): parse_value(v) for k, v in
                                       parse_multiline_multikey_sdict(f.read(),
                                                                      kv_sep = '\t').items()}
                        if num_fields is not None:
                            set_aliases = {k: ((list(v) + (num_fields - len(v))*[''])
                                               if non_string_iter(v)
                                               else [v] + (num_fields - 1)*[''])
                                           for k, v in set_aliases.items()}
                except Exception as e:
                    raise InputFormatError(error_src = "file", hint = f"File: {set_fname}")
            else:
                raise typer.BadParameter( ( f"Unrecognised {description} set lookup file alias or"
                                            f" non-existent file: {val}"
                                            f"\nFor a list of valid {description} set lookup file aliases"
                                            f" and their locations, execute 'minorg {cli_lookup_arg}'."
                                            "\nAlternatively, please provide a valid file of",
                                            f" {description} {lookup_fmt} mapping."
                                            f"\nHelp message for {param.long}: {param.help}") )
        else:
            set_fname = None
            set_aliases = {}
        return val, set_fname, set_aliases
    
    def reference_set_callback(self, val: str) -> str:
        """
        Callback for ``--reference-set <alias or path>``.
        
        Sets self.reference_set and self.reference_aliases.
        
        Arguments:
            val (str): required; lookup file alias or path to lookup file
        
        Returns
        -------
        str
            path to lookup file
        
        Raises
        ------
        InvalidPath
            If path does not exist
        InvalidFile
            If path does not point to a file
        UnreadableFile
            If file is not readable
        InputFormatError
            If format of lookup file is incorrect
        typer.BadParameter
            If argument ``val`` does not point to a valid file
        """
        val, set_fname, set_aliases = self._parse_file_set(val, lookup = self.params.reference_sets,
                                                           description = "reference",
                                                           cli_lookup_arg = "--references",
                                                           lookup_fmt = ("alias-FASTA-GFF3-genetic code"
                                                                         "-attribute modification"),
                                                           param = self.params.reference_set,
                                                           parse_value = (lambda v: v.split('\t')),
                                                           num_fields = 4)
        self.reference_set = set_fname
        self.reference_aliases = {**self.reference_aliases, **set_aliases}
        # self.args.reference_set = val
        return val
    
    def cluster_set_callback(self, val: str) -> str:
        """
        Callback for ``--cluster-set <alias or path>``.
        
        Sets self.cluster_set and self.cluster_aliases.
        
        Arguments:
            val (str): required; lookup file alias or path to lookup file
        
        Returns
        -------
        str
            path to lookup file
        
        Raises
        ------
        InvalidPath
            If path does not exist
        InvalidFile
            If path does not point to a file
        UnreadableFile
            If file is not readable
        InputFormatError
            If format of lookup file is incorrect
        typer.BadParameter
            If argument ``val`` does not point to a valid file
        """
        val, set_fname, set_aliases = self._parse_file_set(val, lookup = self.params.cluster_sets,
                                                           description = "cluster",
                                                           cli_lookup_arg = "--clusters",
                                                           lookup_fmt = "alias-members",
                                                           param = self.params.cluster_set)
        if set_fname:
            self.cluster_set = os.path.abspath(set_fname)
            self.cluster_aliases = {**self.cluster_aliases, **set_aliases}
        return val
    
    def genome_set_callback(self, val: str) -> str:
        """
        Callback for ``--genome-set <alias or path>``.
        
        Sets self.genome_set and self.genome_aliases.
        
        Arguments:
            val (str): required; lookup file alias or path to lookup file
        
        Returns
        -------
        str
            path to lookup file
        
        Raises
        ------
        InvalidPath
            If path does not exist
        InvalidFile
            If path does not point to a file
        UnreadableFile
            If file is not readable
        InputFormatError
            If format of lookup file is incorrect
        typer.BadParameter
            If argument ``val`` does not point to a valid file
        """
        val, set_fname, set_aliases = self._parse_file_set(val, lookup = self.params.genome_sets,
                                                           description = "genome",
                                                           cli_lookup_arg = "--genomes",
                                                           lookup_fmt = "alias-filename",
                                                           param = self.params.genome_set)
        self.genome_set = set_fname
        self.genome_aliases = {**self.genome_aliases, **set_aliases}
        return val
    
    
    ###########################
    ##  RETRIEVE FROM ALIAS  ##
    ###########################
    
    def get_cluster_genes(self, val: str) -> Tuple[str, ...]:
        """
        Get gene members of a cluster.
        
        Uses dictionary self.cluster_aliases for lookup.
        
        Arguments:
            val (str): alias of cluster
        
        Returns
        -------
        tuple
            Tuple of strings, e.g. ('geneA', 'geneB')
        
        Raises
        ------
        click.UsageError
            If ``val`` is not a valid cluster alias
        """
        cluster_genes = self.cluster_aliases.get(val, None)
        if cluster_genes is None:
            raise click.UsageError( (f"'{val}' is not a valid cluster name in"
                                     f" lookup file '{self.cluster_set}'") )
        else:
            return tuple(cluster_genes.split(','))
    
    
    ########################
    ##  LOOKUP CALLBACKS  ##
    ########################
    
    def references_callback(self, value: bool):
        """
        Callback for printing reference genome lookup mapping to terminal.
        Immediately after, resolve temporary directory using :meth:`MINORgCLI.cleanup` 
        and exit programme using ``typer.Exit()``.
        
        Arguments:
            value (bool): print mapping
        """
        if value:
            if self.reference_set is None:
                typer.echo( (f"\nNo reference genomes have been defined."
                             " Please use '--reference-set' to specify a file containing"
                             " alias-FASTA-GFF3 mapping OR use '--assembly <FASTA>' and '--annotation <GFF3>'"
                             " to specify genome sequences and annotations respectively." ))
            else:
                typer.echo(f"\nValid genome aliases (defined in {self.reference_set}):\n")
                typer.echo("<semicolon-separated genome alias(es)>\t<FASTA file>\t<GFF3 file>\t<NCBI genetic code>\t<attribute name mapping>")
                with open(self.reference_set, 'r') as f:
                    aliases = [f.read()]
                typer.echo('\n'.join(aliases) + '\n')
            self.cleanup()
            raise typer.Exit()
    
    def make_genomes_callback(self, mode: str = "independent") -> Callable[[bool],None]:
        """
        Function to make callback for printing query genome lookup mapping to terminal.
        
        Arguments:
            mode (str): valid modes: 'independent', 'dependent'. '.' (all) and '-' (none) in mode 'dependent' are described as referecing ``-g`` input.
        """
        def genomes_callback(value: bool):
            """
            Callback for printing query genome lookup mapping to terminal. 
            Immediately after, resolve temporary directory using :meth:`MINORgCLI.cleanup` 
            and exit programme using ``typer.Exit()``.
            
            Arguments:
                value (bool): print mapping
            """
            if value:
                if self.genome_set is None:
                    typer.echo(f"\nValid genome aliases (defined in {self.params.config_file}):\n")
                    aliases = ['\t'.join(kv) for kv in self.params.indv_genomes.items()]
                else:
                    typer.echo(f"\nValid genome aliases (defined in {self.genome_set}):\n")
                    with open(self.genome_set, 'r') as f:
                        aliases = [f.read()]
                typer.echo("<semicolon-separated genome alias(es)>\t<FASTA file>")
                if mode == "independent":
                    prepend = [".\t<all genomes except reference>",
                               "ref\t<reference genome>"]
                elif mode == "dependent":
                    aliases = [".\t<all genomes passed to -g, including reference>",
                               "-\t<exclude all genomes passed to -g, including reference>",
                               "ref\t<reference genome>"]
                typer.echo('\n'.join(prepend + aliases) + '\n')
                self.cleanup()
                raise typer.Exit()
        return genomes_callback
    
    def clusters_callback(self, value: bool):
        """
        Callback for printing cluster-members lookup mapping to terminal. 
        Immediately after, resolve temporary directory using :meth:`MINORgCLI.cleanup` 
        and exit programme using ``typer.Exit()``.
        
        Arguments:
            value (bool): print mapping
        """
        if value:
            if self.params.cluster_set is not None:
                typer.echo(f"\nThe following information is retrieved from {self.cluster_set}:\n")
                typer.echo("<semicolon-separated cluster alias(es)>\t<comma-separated cluster members>")
                with open(self.cluster_set, 'r') as f:
                    typer.echo(f.read())
            else:
                typer.echo( ("\nNo cluster set lookup file has been specified."
                             "\nYou may update the list of cluster set lookup files"
                             " and set a default set lookup file by modifying the relevant fields in"
                             f" the config file located at {self.params.config_file}"
                             " or provide a set lookup file for a single execution using --cluster-set.") )
            self.cleanup()
            raise typer.Exit()

    def members_callback(self, value: str):
        """
        Callback for printing gene members of a cluster to terminal. 
        Immediately after, resolve temporary directory using :meth:`MINORgCLI.cleanup` 
        and exit programme using ``typer.Exit()``.
        
        Arguments:
            value (str): cluster alias
        """
        if value:
            if value not in self.cluster_aliases:
                if self.params.cluster_set is not None:
                    typer.echo( ( f"{value} is not a valid cluster alias in the following"
                                  f" cluster set lookup file: {self.cluster_set}" ) )
                else:
                    typer.echo( ("\nNo cluster set lookup file has been specified."
                                 "\nYou may update the list of cluster set files"
                                 " and set a default set lookup file by modifying the relevant fields"
                                 f" in the config file located at {self.params.config_file}"
                                 " or provide a set lookup file for a single execution using --cluster-set.") )
            else:
                typer.echo(f"\nThe following information is retrieved from {self.params.cluster_set}:\n")
                typer.echo(self.cluster_aliases[value] + '\n')
            self.cleanup()
            raise typer.Exit()
    
    
    ######################
    ##  ARGS CALLBACKS  ##
    ######################
        
    def attr_mod_callback(self, val) -> dict:
        """
        Callback for ``--attr-mod`` to parse attribute modifications from string to dictionary.
        
        Attribute modification string should be in format
        '<feature type>:<standard attribute field name>=<nonstandard attribute field name>,<standard attribute field name>=<nonstandard attribute field name>;<feature type>:<standard attribute field name>=<nonstandard attribute field name>'. (e.g. 'mRNA:Parent=Locus_id')
        
            - Feature separator: ';'
            - Feature-attribute separator: ':'
            - Attribute-attribute separator: ','
            - Standard name-nonstandard name separator: '='
        
        Arguments:
            val (str): required, string of attribute modifications in format
        
        Returns
        -------
        dict
            parsed attribute modifications in format
                {<feature>: {<standard attribute field name>: <nonstandard attribute field name>}}
        """
        if val and isinstance(val, str):
            try:
                from regex import search
                return self.params.parse_attr_mod(search(r"""[^'"]+""", val).group(0))
            except:
                if val in self.params.attr_mod_presets:
                    raise InputFormatError(message = ( "Unable to parse the GFF attribute modification preset"
                                                       f" ({self.params.attr_mod_presets[val]}) retrieved"
                                                       " from the config file ({self.params.config_file})"
                                                       " via alias '{val}'." ),
                                           hint = self.params.attr_mod.help())
                else:
                    raise InputFormatError(error_src = "for parameter --attr-mod",
                                           hint = self.params.attr_mod.help())
        else: return {}
    
    def domain_callback(self, val: str) -> str:
        """
        Callback for ``--domain`` to parse domain alias or Pssm-Id into Pssm-Id.
        
        Arguments:
            val (str): domain alias or Pssm-Id
        
        Returns
        -------
        str
            Pssm-Id
        """
        if val is not None:
            self.domain_name = val
            parsed_domain = self.params.parse_domain(val)
            if val == "gene":
                self.pssm_ids = []
                return None
            else:
                if str(parsed_domain) == val:
                    typer.echo(f"Parsing input to --domain ({val}) as PSSM-Id")
                self.pssm_ids = [parsed_domain]
                self.domain_name = val
                return parsed_domain
    
    def db_callback(self, val: str) -> Union[str, None]:
        """
        Callback for ``--db`` to parse RPS-BLAST database alias or path into absolute path
        
        Arguments:
            val (str): database alias or path
        
        Returns
        -------
        str
            path to RPS-BLAST database
        """
        if val is not None:
            parsed_db = os.path.abspath(parse_lookup(val, self.params.rps_db_aliases, return_first = True))
            if os.path.exists(parsed_db + '.psi'):
                self.db = parsed_db
                return parsed_db
            else:
                print("Parsing database as remote database")
                self.db = val
                return val
    
    def genetic_code_callback(self, val) -> Union[str, int]:
        """
        Callback for ``--genetic-code`` to parse genetic code as number or name
        
        Arguments:
            val: genetic code number or name
        
        Returns
        -------
        int
            if ``val`` is genetic code number
        str
            if ``val`` is genetic code name
        """
        try: parsed_val = int(val)
        except ValueError: parsed_val = val
        self.genetic_code = parsed_val
        return parsed_val
    
    
    #########################
    ##  MULTI-ARGS CHECKS  ##
    #########################
    
    def reference_required(self, msg):
        """
        Check if at least one reference genome has been provided.
        
        Arguments:
            msg (str): message to append to printed message if there are no referene genomes
        
        Raises
        ------
        click.UsageError
            If no reference genomes are provided
        """
        if (self.args.reference is None
            and (self.args.assembly is None or self.args.annotation is None)
            and (not self.args.ext_gene and not self.args.ext_cds)):
            raise click.UsageError( ("'-r <reference genome alias>' OR"
                                     " '--assembly <reference assembly alias or path to FASTA file>"
                                     " --annotation <reference annotation alias or GFF3 file or"
                                     " BED file converted from GFF3 using gff2bed>' OR"
                                     " '--ext-gene <FASTA file of gene(s)> --ext-cds <FASTA file of CDS>'"
                                     f" is required if using {msg}.") )
    
    def check_reference_args(self, require = False):
        """
        Check reference genome arguments and parse & reformat them for parent :class:`minorg.MINORg.MINORg`.
        
        Priority given to ``--assembly <FASTA> --annotation <GFF3>`` over ``--reference <alias>``.
        
        If ``--ext-gene <FASTA> --ext-cds <FASTA>`` are provided, 
        parse them as well and add them to self.reference.
        
        Arguments:
            require (bool): raise this flag when using self.target. 
                Raises error if ``--target`` is NOT used AND there are NO reference genomes.
        
        Raises
        ------
        click.UsageError
            If ``--target`` is NOT used ``require`` is raised AND there are NO reference genomes.
        click.UsageError
            If ``--ext-gene`` OR ``--ext-cds`` but NOT BOTH is used.
        """
        if self.args.assembly is not None and self.args.annotation is not None:
            if self.args.reference:
                typer.echo("As --assembly and --annotation are used, --reference will be ignored.")
            self.clear_reference()
            self.add_reference(str(self.args.assembly), str(self.args.annotation), alias = "Reference",
                               genetic_code = self.args.genetic_code, attr_mod = self.args.attr_mod)
            self.args.reference = None
        elif self.args.reference:
            none_val = '-'
            valid_aliases(aliases = self.args.reference, lookup = self.reference_aliases,
                          none_value = none_val, all_value = "all",
                          param = self.params.reference, display_cmd = "--references",
                          additional_message = ("Alternatively, provide a FASTA file of a genome assembly using"
                                                " '--assembly <path to FASTA file>' and a GFF3 file of genome"
                                                " annotations using '--annotation <path to GFF3 file>'."))
            self.clear_reference()
            if set(self.args.reference) == {none_val}:
                self.args.reference = None
            else:
                for alias in self.args.reference:
                    fasta, ann, genetic_code, attr_mod = self.reference_aliases[str(alias)]
                    attr_mod = None if attr_mod == '' else attr_mod
                    self.add_reference(fasta, ann, alias = alias, genetic_code = genetic_code,
                                       attr_mod = self.params.parse_attr_mod(attr_mod))
                    # self.extend_reference(alias, fasta, ann)
        ## if --extend-gene or --extend-cds is provided, check that the other is also provided
        if sum(map(lambda x: x is None, [self.args.ext_gene, self.args.ext_cds])) == 1:
            raise click.UsageError( ("'--extend-gene <FASTA file>' and '--extend-cds <FASTA file>'"
                                     " should either be used together or not used at all.") )
        elif self.args.ext_gene and self.args.ext_cds:
            # self.ext_gene = self.args.ext_gene
            # self.ext_cds = self.args.ext_cds
            self.extend_reference(self.args.ext_gene, self.args.ext_cds)
        if require and self.args.target is not None and not self.reference:
            raise click.UsageError((f"Either '--reference <alias>' OR"
                                    " '--assembly <FASTA> --annotation <GFF3>' OR"
                                    " '--ext-gene <FASTA> --ext-cds <FASTA>' is required"
                                    " if '--target <FASTA>' is not used."))
        return
    
    def check_seq_args(self, standalone = True):
        """
        Check arguments for subcommand 'seq' and parse & reformat args for parent :class:`minorg.MINORg.MINORg`.
        
        Arguments:
            standalone (bool): raise this flag when using subcommand 'seq' as standalone 
                and not as part of the full programme.
        
        Raises
        ------
        click.UsageError
            If mutually exclusive arguments or only some of mutually inclusive arguments are used
        """
        ## check if user has provided indv
        indv_provided = not (len(self.args.indv) == 1 and self.args.indv[0] == INDV_GENOMES_NONE)
        ## MUTUALLY EXCLUSIVE ARGS
        ## -q and -t are mutually exclusive
        if self.args.query and self.args.target is not None:
            raise click.UsageError("'-q <FASTA file>' and '-t <FASTA file>' are mutually exclusive.")
        ## -g and -c are mutually exclusive
        if self.args.gene is not None and self.args.cluster is not None:
            raise click.UsageError("'-g <gene(s)>' and '-c <cluster(s)>' are mutually exclusive.")
        ## if checking args for function 'target' and not 'full', then -q/-t are not compatible with -g/-c/-i
        if ( standalone and
             ( ( self.args.target is not None) and
               ( (self.args.gene is not None or self.args.cluster is not None)
                 or (self.args.query or indv_provided) ) ) ):
            raise click.UsageError( ( "'-t <FASTA file>' and"
                                      " '[ -g <gene(s)> or -c <cluster(s)> ]"
                                      " ['-q <FASTA file>' or -i <individual(s)>]'"
                                      " are mutually exclusive.") )
        ## REQUIRED ARGS
        ## check that one of -q, -t, -a|-i is provided
        if not self.args.query and self.args.target is None and not indv_provided:
            raise click.UsageError( ("One of the following is required:"
                                     " '-q <FASTA file>', '-t <FASTA file>', or '-i <individual(s)>'") )
        ## if -t is not used, check that -g/-c is provided
        if self.args.target is None:
            if self.args.gene is None and self.args.cluster is None:
                raise click.UsageError("'-g <gene(s)>' or '-c <cluster(s)>' is required if not using -t.'")
        ## if -g/-c is provided, check that --ref and --annotation are also provided
        if self.args.gene is not None or self.args.cluster is not None:
            self.reference_required("'-g <gene(s)>' or '-c <cluster(s)>'")
            if self.args.query is None and not indv_provided:
                raise click.UsageError( ("'-q <FASTA file>' or '-i <individual(s)>'"
                                         " is required if using '-g <gene(s)>' or '-c <cluster(s)>'.") )
        ## check that --mafft is provided
        if not standalone and self.args.mafft is None:
            raise click.UsageError( "Path to mafft executable is required: --mafft <path>" )
        ## check that --blastn is provided if using -q or '-i <not ref only>'
        if ( (not standalone or self.args.query or (indv_provided and set(self.args.indv) != {"ref"}))
             and self.args.blastn is None):
            raise click.UsageError( "Path to blastn executable is required: --blastn <path>" )
        ## check that --rpsblast is provided if using --domain
        if self.args.domain is not None and self.args.domain != "gene":
            if self.args.rpsblast is None:
                raise click.UsageError( ("'--rpsblast <path to rpsblast or rpsblast+ executable>'"
                                         " is required if using '--domain <domain alias or PSSM-Id>'") )
            if self.args.db is None:
                raise click.UsageError( ("'--db <alias of or path to local RPS-BLAST database"
                                         " OR name of remote RPS-BLAST database>'"
                                         " is required if using '--domain <domain alias or PSSM-Id>'") )
        ## VALID ALIASES (check -r, --annotation, --rps-db, --indv & -c & --attr-mod)
        ## not a callback because it requires config.cluster_aliases generated by cluster_set_callback
        if self.args.cluster is not None:
            valid_aliases(aliases = self.args.cluster, lookup = self.cluster_aliases,
                          param = self.params.cluster, display_cmd = "--clusters",
                          additional_message = ( "Alternatively, manually input the desired genes using"
                                                 " '-g <gene(s)>' or provide a different cluster set"
                                                 " lookup file using '--cluster-set <path to file>'."))
        ## ARGS DEPENDENT ON VALUE OF OTHER ARGS
        ## raise check_recip if relax_recip is raised
        if self.args.relax_recip:
            self.args.check_recip = True
        
        ## FORMAT ARGS FOR AND PASS ARGS TO MINORg
        ## self.query and self.query_references handled separately
        ##  generate query mapping (set self.query)
        query_map = []
        if self.args.query:
            query_map += [[i+1, str(query)] for i, query in enumerate(self.args.query)]
        if indv_provided:
            indvs_special = {INDV_GENOMES_NONE, INDV_GENOMES_REF, INDV_GENOMES_ALL}
            if INDV_GENOMES_REF in self.args.indv:
                self.query_reference = True
            if INDV_GENOMES_ALL in self.args.indv:
                indvs_genome = set(indv for indv in self.genome_aliases if indv not in indvs_special)
            else:
                indvs_genome = set(self.args.indv) - indvs_special
            indvs = (set(self.args.indv) - indvs_special).union(indvs_genome)
            if set(self.args.indv) != {INDV_GENOMES_REF}: self.args.indv = type(self.args.indv)(indvs)
            valid_aliases(aliases = list(indvs_genome), lookup = self.genome_aliases,
                          none_value = INDV_GENOMES_NONE, all_value = INDV_GENOMES_ALL,
                          param = self.params.indv, display_cmd = "--genomes",
                          additional_message = ( "Alternatively, provide a FASTA file of the genome in"
                                                 " which to query using '-q <path to FASTA file>'."))
            query_map += [[indv, self.genome_aliases[str(indv)]] for indv in indvs_genome]#  + \
                         # [[alias, self.reference_aliases[str(alias)][0]] for alias in indvs_ref]
        ## check that file names are unique
        ## - if multiple queries map to the same file, sort by query id and retain first entry
        ## - if same file provided to args.query and args.indv, priorities args.indv regardless of sort order
        query_count = get_count_dict([x[1] for x in query_map])
        query_multi = set(k for k, v in query_count.items() if v > 1)
        self.query = {k: v for k, v in query_map if v not in query_multi}
        for fname in query_multi:
            queries = sorted([x[0] for x in query_map if x[1] == fname])
            self.query[queries[0]] = fname
        return
    
    def check_grna_args(self, standalone = True):
        """
        Check arguments for subcommand 'grna' and parse & reformat args for parent :class:`minorg.MINORg.MINORg`.
        
        Arguments:
            standalone (bool): raise this flag when using subcommand 'grna' as standalone 
                and not as part of the full programme.
        
        Raises
        ------
        click.UsageError
            If mutually exclusive arguments or only some of mutually inclusive arguments are used
        """
        ## MUTUALLY EXCLUSIVE ARGS
        ## -g and -c are mutually exclusive
        if self.args.gene and self.args.cluster:
            raise click.UsageError( ("'-g <gene(s)>' and '-c <cluster(s)>' are mutually exclusive.") )
        # ## -g, -c, and -t are mutually exclusive
        # if sum(map(lambda x: x is not None, [self.args.gene, self.args.cluster, self.args.target])) > 1:
        #     raise click.UsageError( ("'-g <gene(s)>', '-c <cluster(s)>', and '-t <path to FASTA file>'"
        #                              " are mutually exclusive.") )
        if standalone:
            if self.args.target and (self.args.gene or self.args.cluster):
                raise click.UsageError( ("'-t <FASTA>' and '-g <gene(s)>' and '-c <cluster(s)>'"
                                         " are mutually exclusive.") )
        ## REQUIRED ARGS
        ## check that --pam is provided
        if self.args.pam is None:
            raise click.UsageError( "'-p <PAM pattern>' is required." )
        ## check that --length is provided
        if self.args.length is None:
            raise click.UsageError( "'-l <gRNA length (bp)>' is required." )
        ## if -g/-c is provided, check that --ref and --annotation are also provided
        if (self.args.gene is not None or self.args.cluster is not None):
            self.reference_required("'-g <gene(s)>' or '-c <cluster(s)>'")
            # ## set query_reference to True
            # self.query_reference = True
        ## check that --rpsblast is provided if using --domain
        if self.args.domain is not None and self.args.domain != "gene":
            if self.args.rpsblast is None:
                raise click.UsageError( ("'--rpsblast <path to rpsblast or rpsblast+ executable>'"
                                         " is required if using '--domain <domain alias or PSSM-Id>'") )
            if self.args.db is None:
                raise click.UsageError( ("'--db <alias of or path to local RPS-BLAST database"
                                         " OR name of remote RPS-BLAST database>'"
                                         " is required if using '--domain <domain alias or PSSM-Id>'") )
        ## VALID ALIASES (check -r, --annotation, --db, -c)
        ## not a callback because it requires config.cluster_aliases generated by cluster_set_callback
        if self.args.cluster is not None:
            valid_aliases(aliases = self.args.cluster, lookup = self.cluster_aliases,
                          param = self.params.cluster, display_cmd = "--clusters",
                          additional_message = ( "Alternatively, manually input the desired genes using"
                                                 " '-g <gene(s)>' or provide a different cluster set lookup file"
                                                 " using '--cluster-set <path to file>'."))
    
    def check_filter_args(self, standalone = True):
        """
        Check arguments for subcommand 'filter' and parse & reformat args for 
        parent :class:`minorg.MINORg.MINORg`.
        
        Arguments:
            standalone (bool): raise this flag when using subcommand 'filter' as standalone 
                and not as part of the full programme.
        
        Raises
        ------
        click.UsageError
            If mutually exclusive arguments or only some of mutually inclusive arguments are used
        """
        if self.args.screen_reference or self.args.background or self.args.ot_indv:
            self.args.background_check = True
        if standalone:
            if self.args.check_all:
                self.args.gc_check = self.args.feature_check = self.args.background_check = True
            if not self.args.gc_check and not self.args.feature_check and not self.args.background_check:
                raise click.UsageError( ("At least one of the following is required:"
                                         " '--gc-check', '--feature-check', '--background-check'") )
            if self.args.feature_check and not (self.args.target and (self.args.gene or self.args.cluster)):
                raise click.UsageError( ("'--target' and ['--gene' or '--cluster'] are required"
                                         " if using '--feature-check'.") )
            if self.args.cluster and len(self.args.cluster) > 1:
                raise click.BadParameter( ("Multiple clusters (--cluster) are not allowed if using"
                                           " subcommand 'filter'.") )
        else:
            self.args.gc_check = self.args.feature_check = self.args.background_check = True
            if self.args.target:
                if not self.args.gene:
                    self.args.feature_check = False
                # self.args.background_check = False
            if self.args.skip_bg_check:
                self.args.background_check = False
        self.background_check = self.args.background_check
        self.feature_check = self.args.feature_check
        self.gc_check = self.args.gc_check
        ## REQUIRED ARGS
        if standalone:
            if self.args.map is None:
                raise click.UsageError("'--map <path to minorg .map file>' is required.")
            ## commented out because self.grna_fasta will be written when subcmd filter is used regardless of checks
            # if self.args.background_check:
            #     ## if args.grna is not provided, create FASTA file from .map file
            #     if self.args.grna is None:
            #         self.args.grna = self.mkfname("tmp_grna_all.fasta", prefix = False, tmp = True)
            #         grnahits = gRNAHits()
            #         # grnahits.parse_from_mapping(self.args.map, version = None)
            #         grnahits.parse_from_mapping(self.args.map)
            #         grnahits.write_fasta(self.args.grna, write_all = True)
            if self.args.in_place:
                self.args.out_map = self.args.map
        ## feature filter
        if self.args.feature_check:
            if not self.args.feature:
                raise click.UsageError("'--feature <feature>' is required if using '--feature-check'.")
            # if standalone and not self.args.alignment:
            #     raise click.UsageError("'--alignment <path to FASTA> is required if using '--filter-feature'.")
            if not (self.args.gene or self.args.cluster):
                raise click.UsageError( ("'--gene <gene ID(s)>' or '--cluster <cluster alias>'"
                                         " is required if using '--feature-check'.'") )
            if (self.args.gene and self.args.cluster):
                raise click.UsageError("'-g <gene ID(s)>' and '-c <cluster alias(es)>' are mutually exclusive.")
            self.reference_required("'--filter-feature'")
        ## background filter
        if self.args.background_check:
            if self.args.blastn is None:
                raise click.UsageError( "Path to blastn executable is required: --blastn <path>" )
            if self.args.unmask_ref:
                if not self.args.screen_reference:
                    raise click.UsageError( "'--unmask-ref' is only used with '--screen-reference'." )
                if self.args.mask_gene or self.args.mask_cluster:
                    raise click.UsageError( ("'--unmask-ref' should not be used with"
                                             " '--mask-gene' or '--mask-cluster'.") )
                if not standalone and "ref" in self.args.indv:
                    self.logfile.warning( ("'--unmask-ref' will be ignored if 'ref' is provided to '-i'"
                                           " and not excluded using '--ot-indv'. When 'ref' is provided"
                                           " to '-i', the reference genome(s) will be treated the same as"
                                           " any other genomes passed to '-i'.") )
            if self.args.screen_reference and self.is_user_set(self.params.screen_reference):
                if not (self.args.reference or (self.args.assembly and self.args.annotation)):
                    raise click.UsageError("'--reference <reference genome alias>' OR"
                                           " '--assembly <path to FASTA> --annotation <path to GFF3>'"
                                           " is required if using '--screen-reference'.")
            if (not self.args.annotation
                and self.is_user_set(self.params.unmask_gene,
                                     self.params.mask_cluster,
                                     self.params.unmask_cluster)):
                self.reference_required("'--unmask-gene', '--mask-cluster', or '--unmask-cluster'")
            if self.args.ot_mismatch is None: self.args.ot_mismatch = 1
            if self.args.ot_gap is None: self.args.ot_mismatch = 0
            if not self.args.ot_pamless and self.args.pam is None:
                raise click.UsageError("'--pam <PAM pattern>' is required if not using '--ot-pamless'.")
            ## convert background filenames to str
            self.args.background = [str(fname) for fname in self.args.background]
            if self.args.pam is not None:
                if standalone:
                    ## set minimum length for least restrictive regex
                    self.length = 1
                    self.parse_PAM()
                else:
                    self.parse_PAM()
            if self.args.background:
                for i, fname in enumerate(self.args.background):
                    self.add_background(fname, alias = f"bg_{str(i+1).zfill(3)}")
            if self.args.ot_indv:
                expanded_indv = set(self.args.ot_indv)
                if standalone and (REFERENCED_ALL in self.args.ot_indv or REFERENCED_NONE in self.args.ot_indv):
                    raise MINORgError( (f"'{REFERENCED_ALL}' and '{REFERENCED_NONE}'"
                                        " are not valid for --ot-indv if using subcommand filter"
                                        " as standalone") )
                if REFERENCED_ALL in self.args.ot_indv and REFERENCED_NONE in self.args.ot_indv:
                    raise MINORgError( (f"'{REFERENCED_ALL}' and '{REFERENCED_NONE}'"
                                        " are mutually exclusive for --ot-indv") )
                if REFERENCED_ALL in self.args.ot_indv:
                    expanded_indv -= {REFERENCED_ALL}
                    expanded_indv |= set(self.args.indv)
                    if INDV_GENOMES_REF in expanded_indv:
                        expanded_indv -= {INDV_GENOMES_REF}
                        self.screen_reference = True
                    if INDV_GENOMES_NONE in expanded_indv:
                        expanded_indv -= {INDV_GENOMES_NONE}
                elif REFERENCED_NONE in self.args.ot_indv:
                    expanded_indv -= {REFERENCED_NONE}
                    expanded_indv -= set(self.args.indv)
                for indv in expanded_indv:
                    if str(indv) not in self.genome_aliases:
                        raise MINORgError(f"Unknown genome alias: '{indv}'")
                    self.add_background(self.genome_aliases[str(indv)], alias = str(indv))
    
    ##########################
    ##  MULTI-ARGS PARSERS  ##
    ##########################
    
    def parse_cluster(self) -> dict:
        """
        Map self.args.cluster aliases to genes
        
        Returns
        -------
        dict
            {<prefix>: (<genes>,)}
        """
        output = {}
        for cluster in self.args.cluster:
            output[f"{self.master_prefix}_{cluster}"] = tuple(self.get_cluster_genes(cluster))
        return output
    
    def parse_genes(self):
        """
        Set self.gene_sets.
        
        To be called after ``--gene`` or ``--cluster`` have passed check_seq_args checks.
        self.gene_sets = {} if ``--target`` is used.
        Else self.gene_sets = {'<prefix>_<cluster>': ('gene1', 'gene2', 'gene3')} if ``--cluster`` is used
        else self.gene_sets = {'<prefix>': ('gene1', 'gene2', 'gene3')} if ``--gene`` is used.
        """
        if self.args.cluster is None:
            output = {self.master_prefix: tuple([] if self.args.gene is None else self.args.gene)}
        else:
            output = self.parse_cluster()
        self.gene_sets = output
    
    def parse_genes_for_filter(self, priority = None, standalone = False):
        """
        Set self.mask_gene_sets.
        
        To be called after ``--mask``, ``--unmask``, ``--mask-cluster``, ``--unmask-cluster``, 
        and ``--gene`` have passed check_filter_args checks.
        
        self.mask_gene_sets = {'mask': ('gene1', 'gene2'), 'unmask': ('gene3',)}
        """
        ## if standalone, combine all clusters (if any) into a single gene set under the master prefix
        if standalone:
            self.gene_sets = {self.master_prefix: tuple(itertools.chain(*self.gene_sets.values()))}
        # genes = (set() if self.args.gene is None else set(self.args.gene))
        genes = set()
        if self.gene_sets: genes |= set(itertools.chain(*self.gene_sets.values()))
        # if self.cluster: genes |= set(itertools.chain(*self.parse_cluster.values()))
        mask_genes = set((tuple() if self.args.mask_gene is None else tuple(self.args.mask_gene)) + \
                         (tuple() if self.args.mask_cluster is None else
                          tuple(itertools.chain(*[self.get_cluster_genes(cluster)
                                                  for cluster in self.args.mask_cluster]))))
        unmask_genes = set((tuple() if self.args.unmask_gene is None else tuple(self.args.unmask_gene)) + \
                           (tuple() if self.args.unmask_cluster is None else
                            tuple(itertools.chain(*[self.get_cluster_genes(cluster)
                                                    for cluster in self.args.unmask_cluster]))))
        ## parse '.' for 'all genes passed to --gene/--cluster'
        def expand_genes(genes_to_expand):
            if REFERENCED_ALL in genes_to_expand and REFERENCED_NONE in genes_to_expand:
                raise MINORgError( (f"'{REFERENCED_ALL}' and '{REFERENCED_NONE}'"
                                    " are mutually exclusive for --mask-gene and --unmask-gene") )
            if REFERENCED_ALL in genes_to_expand:
                genes_to_expand -= {REFERENCED_ALL}
                genes_to_expand |= genes
            elif REFERENCED_NONE in genes_to_expand:
                genes_to_expand -= {REFERENCED_NONE}
                genes_to_expand -= genes
            return genes_to_expand
        mask_genes = expand_genes(mask_genes)
        unmask_genes = expand_genes(unmask_genes)
        overlap_genes = mask_genes.intersection(unmask_genes)
        ## check for overlaps between mask and unmask if priority is not set
        if priority is None and overlap_genes:
            raise MINORgError( ("The following genes were provided to both"
                                " --mask-gene/--mask-cluster and --unmask-gene/--unmask-gene:"
                                f" {','.join(sorted(overlap_genes))}") )
        ## generate output dictionary
        output = {}
        if priority == "mask":
            output["mask"] = tuple(mask_genes)
            output["unmask"] = tuple(unmask_genes - mask_genes)
        elif priority == "unmask":
            output["mask"] = tuple(mask_genes - unmask_genes)
            output["unmask"] = tuple(unmask_genes)
        else:
            output["mask"] = tuple(mask_genes)
            output["unmask"] = tuple(unmask_genes)
        self.mask_gene_sets = output
        self.genes = list(genes.union(mask_genes))
        return
        
    def parse_PAM(self):
        """
        Parse PAM by converting aliases of preset PAM patterns to PAM patterns.
        
        To be called after ``--pam`` and ``--length`` have passed check_grna_args checks OR
                     after ``--pam`` has passed check_filter_args (standalone) checks
        """
        if self.args.pam in PAM_PATTERNS:
            self.pam = PAM_PATTERNS[self.args.pam]
        else:
            if self.verbose:
                print(f"Parsing {self.args.pam} as PAM pattern.")
            self.pam = self.args.pam
        return
    
    def parse_ot_pattern(self):
        """
        Parse off-target pattern.
        """
        self.ot_unaligned_as_mismatch = self.args.ot_unaligned_as_mismatch
        self.ot_unaligned_as_gap = self.args.ot_unaligned_as_gap
        self.ot_pattern = self.args.ot_pattern
        return
    
    #######################
    ##  MASTER ARGPARSE  ##
    #######################
    
    ## implements appropriate parsers for each argument
    def parse_args(self, args, subcmd: str):
        """
        Parse and check arguments pre-parsed by Typer by calling the appropriate parsers based on subcommand.
        
        After parsing, write parsed args to logfile.
        
        Arguments:
            args (Namespace): required, arguments
            subcmd (str): required, subcommand name.
                Valid subcmd: seq, (homologue, homolog, target,) grna, filter, (check,) minimumset, full
        """
        self.args = args
        ## set output options
        if self.args.prefix:
            self.master_prefix = self.args.prefix
            self.prefix = self.args.prefix ## this may be updated by target OR full for each cluster
        if self.args.directory:
            self._mv_frm_tmp(self.args.directory)
        ## make MINORG dir
        self.mkdir(self.master_prefix)
        ## check the appropriate args are used for each subcmd
        ## (no checks for subcmd minimumset)
        if subcmd in ["homologue", "homolog", "target", "seq"]:
            self.parse_seq_args()
        elif subcmd in ["grna"]:
            self.parse_grna_args()
        elif subcmd in ["filter", "check"]:
            self.parse_filter_args()
        elif subcmd in ["minimumset"]:
            self.parse_minimumset_args()
        elif subcmd in ["full"]:
            self.parse_full_args()
        ## write args to logfile
        self.logfile.args_expanded([self.args, self.params])
    
    def parse_seq_args(self):
        """
        Parse and check arguments for subcommand seq.
        """
        self.check_reference_args()
        self.check_seq_args(standalone = True)
        self.parse_genes()
        self.subset_annotation(quiet = True)
        ## PASS ARGS TO MINORg
        ## args handled by callbacks: domain
        ## args handled separately by parser: cluster, gene --> self.gene_sets
        ## args handled by check_reference_args: ext_gene, ext_cds, attr_mod
        ## args handled by check_target_args: query, indv, target --> self.query/self.target
        self.copy_args("blastn", "mafft", "rpsblast", "db", "remote_rps", "thread",
                       "target", "feature", "check_recip", "relax_recip",
                       "minid", "minlen", "mincdslen", "check_id_before_merge", "merge_within")
        return
    
    def parse_grna_args(self):
        """
        Parse and check arguments for subcommand grna.
        """
        self.check_reference_args()
        self.check_grna_args(standalone = True)
        self.parse_genes()
        self.subset_annotation(quiet = True)
        ## PASS ARGS TO MINORg
        ## args handled by callbacks: domain
        ## args handled by check_reference_args: ext_gene, ext_cds, attr_mod
        ## args handled separately by parser: cluster, gene --> self.gene_sets
        self.copy_args("rpsblast", "db", "remote_rps", "thread", "target", "length", "feature")
        self.parse_PAM()
        self.grna_map = self.args.out_map
        self.grna_fasta = self.args.out_fasta
        self.pass_fasta = self.args.out_pass
        self.query_reference = (self.args.cluster or self.args.gene)
        return
    
    def parse_filter_args(self):
        """
        Parse and check arguments for subcommand filter.
        """
        self.copy_args("screen_reference") ## may be modified by check_filter_args based on --ot-indv
        self.check_reference_args()
        self.check_filter_args(standalone = True)
        self.parse_genes()
        self.parse_genes_for_filter(standalone = True)
        self.subset_annotation(quiet = True)
        ## FORMAT ARGS FOR AND PASS ARGS TO MINORg
        ## args handled by check_reference_args: ext_gene, ext_cds, attr_mod
        self.copy_args("blastn", "mafft", "thread",
                       "mask",
                       "gc_min", "gc_max",
                       "ot_mismatch", "ot_gap", "ot_pamless",
                       "target", "feature", "max_insertion", "min_within_n", "min_within_fraction")
        ## args that require a little more parsing/have different names
        ## PAM
        self.parse_PAM()
        self.parse_grna_map_from_file(self.args.map)
        if self.args.rename:
            self.rename_grna(str(self.args.rename.resolve()))
        if self.args.reset_checks:
            self.grna_hits.clear_checks()
        ## off-target pattern
        self.parse_ot_pattern()
        ## filenames
        self.grna_fasta = self.args.out_fasta
        self.grna_map = self.args.out_map
        self.pass_fasta = self.args.out_pass
        return
    
    def parse_minimumset_args(self):
        """
        Parse and check arguments for subcommand minimumset.
        """
        if ( self.args.out_map is None or self.args.out_fasta is None ):
            typer.echo(f"Output files will be generated in '{self.directory}' with the prefix '{self.prefix}'.")
        self.copy_args("sets", "auto", "prioritise_nr", "exclude", "target",
                       # "accept_feature_unknown",
                       "accept_invalid")
        ## args that require a little more parsing/have different names
        self.parse_grna_map_from_file(self.args.map)
        if self.args.rename:
            self.rename_grna(str(self.args.rename.resolve()))
        # self.grna_fasta = self.args.grna
        self.final_map = self.args.out_map
        self.final_fasta = self.args.out_fasta
        return
    
    def parse_full_args(self):
        """
        Parse and check arguments for full programme.
        """
        # print(dir(self._raw_args))
        # self.is_user_set(self.params.target)
        # self.is_user_set(self.params.feature)
        # self.is_user_set(self.params.target, self.params.feature, a = False)
        # self.is_user_set(self.params.target, self.params.feature, a = True)
        self.copy_args("screen_reference") ## may be modified by check_filter_args based on --ot-indv
        self.check_reference_args()
        self.check_seq_args(standalone = False)
        self.check_grna_args(standalone = False)
        self.check_filter_args(standalone = False)
        self.parse_genes()
        self.parse_genes_for_filter(priority = "unmask", standalone = False)
        self.subset_annotation(quiet = True)
        ## PASS ARGS TO MINORg
        ## args handled by callbacks: domain
        ## args handled separately by parser: cluster, gene --> self.gene_sets
        ## args handled by check_reference_args: ext_gene, ext_cds, attr_mod
        ## args handled by check_target_args: query, indv, target --> self.query/self.target
        self.copy_args("blastn", "mafft", "rpsblast", ## executables
                       "db", "remote_rps", ## database
                       "thread",
                       "target", "feature", "check_recip", "relax_recip", ## target definition
                       "minid", "minlen", "mincdslen", "check_id_before_merge", "merge_within",
                       "target", "length", ## gRNA generation
                       "gc_min", "gc_max", ## filtering options
                       "ot_mismatch", "ot_gap", "ot_pamless",
                       "feature", "max_insertion", "min_within_n", "min_within_fraction",
                       "sets", "auto", "prioritise_nr", "exclude",
                       # "accept_feature_unknown",
                       "accept_invalid") ## minimum set options
        self.parse_PAM()
        ## off-target pattern
        self.parse_ot_pattern()
        return
    
    #######################
    ##  GENE SET MINORg  ##
    #######################

    def set_genes(self, gene_set_prefix):
        """
        Specify a gene set to be processed by parent :class:`minorg.MINORg.MINORg`.
        
        As :class:`~minorg.MINORg.MINORg` only processes genes in :attr:`~minorg.MINORg.genes`, 
        this method sets :attr:`~minorg.MINORg.genes` as the genes mapped to by ``gene_set_prefix`` 
        so that they can be acted.
        
        Setting self.genes automatically sets self._genes_updated_since_alignment=True if 
        the new gene set is different so that MINORg knows to update alignments with new genes.
        
        Arguments:
           gene_set_prefix (str): required, gene set alias (valid aliases: self.gene_sets.keys())
        """
        if gene_set_prefix not in self.gene_sets:
            print(f"{gene_set_prefix} not in gene_sets ({', '.join(self.gene_sets.keys())}).")
        self.prefix = gene_set_prefix
        self.genes = self.gene_sets[gene_set_prefix]
        # self._genes_updated_since_alignment = True
        # if (set(self.genes) != set(self.gene_sets[gene_set_prefix])):
        #     self.genes = self.gene_sets[gene_set_prefix]
        #     self._genes_updated_since_alignment = True
    
    ######################
    ##  PREFIX MATTERS  ##
    ######################
    
    def reset_prefix(self):
        self.prefix = self.args.prefix
    
    ################
    ##  WRAPPERS  ##
    ################
    
    def minimumset(self, *args, **kwargs):
        """
        Wrapper for MINORg.minimumset that excludes checks based on self.XX_check.
        """
        super().minimumset(*args, **kwargs,
                           exclude_check = (self.exclude is not None),
                           gc_check = self.gc_check,
                           background_check = self.background_check,
                           feature_check = self.feature_check)
        
    ##############
    ##  SUBCMD  ##
    ##############
    
    def subcmd_seq(self):
        """
        Subcommand seq.
        
        If ``--cluster`` is used, processes each cluster's set of genes separately.
        Writes target sequences to FASTA file.
        """
        for prefix in self.gene_sets:
            self.set_genes(prefix)
            with warnings.catch_warnings():
                warnings.filterwarnings("error",
                                        message = "minorg.MINORgWarning: No target sequences found.",
                                        category = MINORgWarning)
                try:
                    super().seq(quiet = False)
                except MINORgWarning as e:
                    print(e.message)
                    if self.args.cluster:
                        warnings.warn(f"No target sequences found for {prefix}.",
                                      MINORgWarning)
                    else:
                        warnings.warn(("No target sequences found for this set of genes:"
                                       f" {','.join(self.genes)}"),
                                      MINORgWarning)
        self.reset_prefix()
        return
    
    def subcmd_grna(self):
        """
        Subcommand grna.
        
        If ``--cluster`` is used, processes each cluster's set of genes separately.
        Writes all possible gRNA to FASTA file.
        """
        for prefix in self.gene_sets:
            self.set_genes(prefix)
            with warnings.catch_warnings():
                warnings.filterwarnings("error",
                                        message = "minorg.MINORgWarning: No target sequences found.",
                                        category = MINORgWarning)
                try:
                    if not self.target:
                        super().seq(quiet = False)
                except MINORgWarning as e:
                    print(e.message)
                    if self.args.cluster:
                        warnings.warn(f"No target sequences found for {prefix}.",
                                      MINORgWarning)
                    else:
                        warnings.warn(("No target sequences found for this set of genes:"
                                       f" {','.join(self.genes)}"),
                                      MINORgWarning)
            super().grna()
            super().filter_feature()
            super().filter_gc()
            self.write_all_grna_map()
            self.write_pass_grna_fasta()
        self.reset_prefix()
        return
    
    def subcmd_filter(self):
        """
        Subcommand filter.
        
        Executes background, feature, and GC check.
        Writes .map file detailing check statuses of each gRNA-target combination.
        """
        if self.grna_fasta is None:
            self.write_all_grna_fasta()
        if self.background_check:
            print("Executing background check")
            self.filter_background()
            if self.keep_tmp:
                self.write_mask_report(self.mkfname("mask_report.tsv"))
        if self.feature_check:
            print("Executing feature check")
            self.filter_feature()
        if self.gc_check:
            print("Executing GC check")
            self.filter_gc()
        self.write_all_grna_map()
        self.write_pass_grna_fasta()
        return
    
    ## somewhat tested
    def subcmd_minimumset(self):
        """
        Subcommand minimumset.
        
        Generates minimumset of gRNA required to cover all targets.
        Writes FASTA file of final set of gRNA and .map file detailing targets of each gRNA.
        """
        self.minimumset(report_full_path = False)
        return
    
    def subcmd_full(self):
        """
        Full MINORg programme.
        """
        ## generate sequences to mask
        self.mask = self.args.mask
        ## TODO: fix this empty file. and also make it so that genes will be masked
        ## using sequence in complete feature range.
        if self.background_check and self.mask_gene_sets["mask"]:
            # print("mask_gene_sets['mask']:", self.mask_gene_sets["mask"])
            to_mask = self.reserve_fname("to_mask.fasta", tmp = True)
            self._get_reference_seq(self.mask_gene_sets["mask"], *self.features,
                                    adj_dir = True, fout = to_mask)
            self.mask.append(to_mask)
        ## execute MINORg
        for prefix in self.gene_sets:
            self.set_genes(prefix)
            def warn_skip(msg):
                warnings.warn(f"{msg} Skipping this gene set: {','.join(self.genes)}", MINORgWarning)
            ## get targets if not user-provided
            # if self.genes:
            with warnings.catch_warnings():
                warnings.filterwarnings("error", message = "No targets found.",
                                        category = MINORgWarning)
                warnings.filterwarnings("error", message = "No gRNA found.",
                                        category = MINORgWarning)
                warnings.filterwarnings("error", message = "No vaid gRNA after filtering.",
                                        category = MINORgWarning)
                warnings.filterwarnings("ignore", message = "The following .* check\(s\) have not been set: .*",
                                        category = MINORgWarning)
                try:
                    super().full(background_check = self.background_check,
                                 feature_check = self.feature_check,
                                 gc_check = self.gc_check)
                except MINORgWarning as w:
                    warnings.filterwarnings("default", category = MINORgWarning)
                    warn_skip(str(w))
            #     if not self.args.target:
            #         try:
            #             super().seq(quiet = False)
            #             warnings.warn("No target sequences found.", MINORgWarning)
            #         ## abort current gene combo if no targets
            #         except MINORgWarning as w:
            #             print(dir(w), str(w), w.args)
            #             warn_skip("No targets found.")
            #             continue
            # super().grna()
            # ## abort if no gRNA
            # if len(self.grna_hits) == 0:
            #     warn_skip("No gRNA found.")
            #     continue
            # ## filter
            # if self.background_check:
            #     self.logfile.devsplain("Filtering background")
            #     super().filter_background()
            # if self.feature_check:
            #     self.logfile.devsplain("Filtering feature")
            #     super().filter_feature()
            # if self.gc_check:
            #     self.logfile.devsplain("Filtering GC")
            #     super().filter_gc()
            # self.write_all_grna_map()
            # ## abort if no gRNA pass
            # if len(self.valid_grna()) == 0:
            #     warn_skip("No valid gRNA after filtering.")
            # ## minimumset
            # self.minimumset(report_full_path = False)
        self.reset_prefix()
        return
            
