# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_HuckelSolver.ipynb.

# %% auto 0
__all__ = ['norm', 'mapper', 'generate_smiles', 'Huckel_solve', 'Huckel']

# %% ../nbs/00_HuckelSolver.ipynb 3
#| echo: false
from rdkit import Chem
from rdkit.Chem.Draw import rdMolDraw2D
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import Draw
from IPython.display import SVG, Image
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.cm as cm

# %% ../nbs/00_HuckelSolver.ipynb 4
IPythonConsole.ipython_useSVG=True  #< set this to False if you want PNGs instead of SVGs
IPythonConsole.drawOptions.addAtomIndices = True
norm = matplotlib.colors.Normalize(vmin=-1, vmax=1, clip=True)
mapper = cm.ScalarMappable(norm=norm, cmap='coolwarm')

# %% ../nbs/00_HuckelSolver.ipynb 5
def generate_smiles(l_or_r:str, # linear or ring
                    n:int     # the number of atoms in the molecule
                    ):
    """
    generate the smiles of either a straight chain or ring polyene, with n atoms.
    All carbons will be sp2 hybridised.
    For linear molecules with an odd number of atoms it will return the anion
    For rings with 4n+1 atoms it will return the anion eg C5H5-
    For rings with 4n+3 atoms it will return the cation eg C7H7+
    """
    unit = 'C=C' # the base 2 carbon double bond unit
    if n<3: l_or_r = 'linear' #ring needs at least 3 atoms
    if n <=1:
        raise Exception("More than 1 Carbon atoms is needed")
    if not isinstance(n, int):
        raise Exception("An integer number of atoms is needed")
    if l_or_r == 'linear':
        repeats = n//2 # repeats of the base unit of 2 carbons
        terminal = n%2 # whether or not a terminal carbon is needed
        output = repeats*unit +terminal*"[CH2+]"
    if l_or_r == 'ring':
        repeats = n//2 # repeats of the base unit of 2 carbons
        cation_terminal = 1 if n%4==3 else 0 # if 4n+3 carbon atoms: cation eg C7H7+
        anion_terminal = 1 if n%4==1 else 0 # if 4n+3 carbon atoms: cation eg C5H5-
        output = "C1=C" +(repeats-1)*unit +anion_terminal*"[CH-]"+cation_terminal*"[CH+]"+"1"
    return output

# %% ../nbs/00_HuckelSolver.ipynb 6
def Huckel_solve(matrix):
    """
    From a Huckel matrix input, solve for the Huckel pi system
    Returns a dictionary of energy levels with the associated (possibly degenerate) wavefunctions
    """
    vals, vecs = np.linalg.eig(matrix)
    # create dictionary where each eigenvalue has a list of the associated eigenvectors
    energy_dict = {}
    for i, val in enumerate(vals):
        # pythons eigenvalues sometimes produce rounding errors at the 14th dp: eg eigenvalues for benzene being 1.0 and 0.9999999999999998
        # similarly, trivial imaginary parts are occasionally produced: on the order of 10^-16 i
        val = round(np.real(val), 3)
        if val in energy_dict:
            energy_dict[val].append(vecs[:,i])
        else: energy_dict[val]=[vecs[:,i]]
    return energy_dict

# %% ../nbs/00_HuckelSolver.ipynb 7
class Huckel:
    """The solution to the Huckel equation for a molecule given as SMILES"""
    def __init__(self, SMILES:str="c1ccccc1"):
        self.smiles = SMILES
        self.molecule = Chem.MolFromSmiles(SMILES)
        self.matrix = -Chem.GetAdjacencyMatrix(self.molecule)
        self.energy_dict = Huckel_solve(self.matrix)
    def plot(self):
        """
        Plots an MO diagram based on a dictionary of energy levels and associated wavefunctions
        """
        fig, ax = plt.subplots()
        plt.tick_params(
        axis='x',          # changes apply to the x-axis
        which='both',      # both major and minor ticks are affected
        bottom=False,      # ticks along the bottom edge are off
        top=False,         # ticks along the top edge are off
        labelbottom=False) # labels along the bottom edge are off
        for level in self.energy_dict:
            degeneracy = len(self.energy_dict[level])
            x = np.arange(-(0.5*(degeneracy - 1)),(0.5*(degeneracy)), 1)
            y = [level]*(degeneracy)
            ax.scatter(x, y, s =900, marker = '_', linewidth = 3)
        plt.show()
    def __str__(self):
        string = 'Huckel Energies (degeneracy) for ' +self.smiles +':'
        for level in dict(sorted(self.energy_dict.items())): #this sorts the energy levels in order from lowest to highest
            degeneracy = len(self.energy_dict[level])
            string = string + " [%.3f (%d)] " % (level, degeneracy)
        return string
