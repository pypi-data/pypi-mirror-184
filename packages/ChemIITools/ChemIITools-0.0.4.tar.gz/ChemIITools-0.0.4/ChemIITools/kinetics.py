# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_Kinetics.ipynb.

# %% auto 0
__all__ = ['steady_state_calc', 'oreg_calc']

# %% ../nbs/02_Kinetics.ipynb 2
#| echo: false
import numpy as np

# %% ../nbs/02_Kinetics.ipynb 4
def steady_state_calc(kf1:float, # rate constant for D->I
                      kr1:float, # rate constant for I->D
                      kf2:float, # rate constant for I->N
                      kr2:float  # rate constant for N->I
                      ):
    """
    Calculate the steady state equilibrium of reaction D<->I<->N, given the rate of the forwards and backwards processes at each step
    """
    mat = np.array([[-kf1,kr1,0],[0,kf2,-kr2],[1,1,1]])
    vec = np.array([0,0,1])
    mat_inv = np.linalg.inv(mat)
    out = np.matmul(mat_inv, vec)
    return out

# %% ../nbs/02_Kinetics.ipynb 10
def _deriv(t, concs, k1, k2, k3, k4, k5):
    """
    Returns the time derivatives of concs = A, B, X, Y, Z, P, Q
    """
    A, B, X, Y, Z, P, Q = concs
    r1 = A*Y*k1
    r2 = X*Y*k2
    r3 = B*X*k3
    r4 = X*X*k4
    r5 = Z*k5
    return -r1, -r3, r1 -r2 +r3 -2*r4, -r1-r2+r5, r3-r5, r1 +r2, r4

# %% ../nbs/02_Kinetics.ipynb 15
def oreg_calc(concs:list, # the concentrations [A,B,X,Y,Z,P,Q]
              method:str = 'Euler', # the method to use for the integrator
              tmax:float = 90, # the interval over which to run the integrator
              dt:float =2e-6, # the time step for the integrator
              k1:float =1.34, # the rate constant for A + Y -> X + P
              k2:float =1.6e9,# the rate cosntant for X + Y -> P
              k3:float =8e3,  # the rate constant for B + X -> 2X + Z
              k4:float =4e7,  # the rate constant for 2X -> Q
              k5:float =1     # the rate constant for Z -> Y
              ):
    """
    Calculates the time dependent concentrations of species in the oregonator system using the Euler method
    """
    t = np.arange(0, tmax+dt, dt)
    conc_t = np.zeros((len(t),len(concs)))
    conc_t[0] = concs
    if method == 'Euler':
        for i, c in enumerate(conc_t[:-1]):
            rk_1 = _deriv(1, c, k1,k2,k3,k4,k5)
            rk_1 = np.array(rk_1)
            conc_t[i+1]= c + rk_1*dt
    elif method == 'midpoint':
        for i, c in enumerate(conc_t[:-1]):
            rk_1 = np.array(_deriv(1, c, k1,k2,k3,k4,k5))
            rk_2 = np.array(_deriv(1, c+dt*rk_1/2, k1,k2,k3,k4,k5))
            conc_t[i+1]=c+dt*(rk_2)
    elif method == 'Heun3':
        for i, c in enumerate(conc_t[:-1]):
            rk_1 = np.array(_deriv(1, c, k1,k2,k3,k4,k5))
            rk_2 = np.array(_deriv(1, c+dt*rk_1/3, k1,k2,k3,k4,k5))
            rk_3 = np.array(_deriv(1, c+dt*2*rk_2/3, k1,k2,k3,k4,k5))
            conc_t[i+1]=c+dt*(rk_1+3*rk_3)/4
    elif method == 'SSPRK3':
        for i, c in enumerate(conc_t[:-1]):
            rk_1 = np.array(_deriv(1, c, k1,k2,k3,k4,k5))
            rk_2 = np.array(_deriv(1, c+dt*rk_1, k1,k2,k3,k4,k5))
            rk_3 = np.array(_deriv(1, c+dt*(rk_1+rk_2)/4, k1,k2,k3,k4,k5))
            conc_t[i+1]=c+dt*(rk_1+rk_2+4*rk_3)/6
    elif method == 'RK4':
        for i, c in enumerate(conc_t[:-1]):
            rk_1 = np.array(_deriv(1, c, k1,k2,k3,k4,k5))
            rk_2 = np.array(_deriv(1, c+dt*rk_1/2, k1,k2,k3,k4,k5))
            rk_3 = np.array(_deriv(1, c+dt*rk_2/2, k1,k2,k3,k4,k5))
            rk_4 = np.array(_deriv(1, c+dt*rk_3, k1,k2,k3,k4,k5))
            conc_t[i+1]=c+dt*(rk_1+2*rk_2+2*rk_3+rk_4)/6
    else:
        raise ValueError('The only method currently implemented are Euler, midpoint, Heun3, SSPRK3 and RK4')
    conc_t = conc_t.transpose()
    return t, conc_t
