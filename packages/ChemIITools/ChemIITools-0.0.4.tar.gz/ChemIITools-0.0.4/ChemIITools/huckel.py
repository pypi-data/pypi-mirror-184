# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_HuckelSolver.ipynb.

# %% auto 0
__all__ = ['generate_smiles', 'Huckel_solve', 'Huckel']

# %% ../nbs/00_HuckelSolver.ipynb 3
#| echo: false
from rdkit import Chem
from rdkit.Chem.Draw import rdMolDraw2D
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import Draw
from IPython.display import SVG, Image
import numpy as np
import matplotlib.pyplot as plt

# %% ../nbs/00_HuckelSolver.ipynb 4
IPythonConsole.ipython_useSVG=True  #< set this to False if you want PNGs instead of SVGs
IPythonConsole.drawOptions.addAtomIndices = True

# %% ../nbs/00_HuckelSolver.ipynb 5
def generate_smiles(l_or_r:str, # linear or ring
                    n:int     # the number of atoms in the molecule
                    ):
    """
    generate the smiles of either a straight chain or ring polyene, with n atoms.
    All carbons will be sp2 hybridised.
    For linear molecules with an odd number of atoms it will return the anion
    For rings with 4n+1 atoms it will return the anion eg C5H5-
    For rings with 4n+3 atoms it will return the cation eg C7H7+
    """
    unit = 'C=C' # the base 2 carbon double bond unit
    if n<3: l_or_r = 'linear' #ring needs at least 3 atoms
    if n <=1:
        raise Exception("More than 1 Carbon atoms is needed")
    if not isinstance(n, int):
        raise Exception("An integer number of atoms is needed")
    if l_or_r == 'linear':
        repeats = n//2 # repeats of the base unit of 2 carbons
        terminal = n%2 # whether or not a terminal carbon is needed
        output = repeats*unit +terminal*"[CH2+]"
    if l_or_r == 'ring':
        repeats = n//2 # repeats of the base unit of 2 carbons
        cation_terminal = 1 if n%4==3 else 0 # if 4n+3 carbon atoms: cation eg C7H7+
        anion_terminal = 1 if n%4==1 else 0 # if 4n+3 carbon atoms: cation eg C5H5-
        output = "C1=C" +(repeats-1)*unit +anion_terminal*"[CH-]"+cation_terminal*"[CH+]"+"1"
    return output

# %% ../nbs/00_HuckelSolver.ipynb 6
def Huckel_solve(matrix):
    """
    From a Huckel matrix input, solve for the Huckel pi system
    Returns a dictionary of energy levels with the associated (possibly degenerate) wavefunctions
    """
    vals, vecs = np.linalg.eig(matrix)
    # create dictionary where each eigenvalue has a list of the associated eigenvectors
    energy_dict = {}
    for i, val in enumerate(vals):
        # pythons eigenvalues sometimes produce rounding errors at the 14th dp: eg eigenvalues for benzene being 1.0 and 0.9999999999999998
        # similarly, trivial imaginary parts are occasionally produced: on the order of 10^-16 i
        val = round(np.real(val), 3)
        if val in energy_dict:
            energy_dict[val].append(vecs[:,i])
        else: energy_dict[val]=[vecs[:,i]]
    return energy_dict

# %% ../nbs/00_HuckelSolver.ipynb 7
class Huckel:
    """The solution to the Huckel equation for a molecule given as SMILES"""
    def __init__(self, SMILES:str="c1ccccc1"):
        self.smiles = SMILES
        self.molecule = Chem.MolFromSmiles(SMILES)
        self.matrix = -Chem.GetAdjacencyMatrix(self.molecule)
        self.matrix = -Chem.GetAdjacencyMatrix(self.molecule)

    @property
    def energy_dict(self):
        return Huckel_solve(self.matrix)
    @energy_dict.setter
    def energy_dict(self, value):
        raise Exception("Energy is determined by Huckel matrix and so read only")

    def plot(self):
        """
        Plots an MO diagram based on a dictionary of energy levels and associated wavefunctions
        """
        fig, ax = plt.subplots()
        plt.tick_params(
        axis='x',          # changes apply to the x-axis
        which='both',      # both major and minor ticks are affected
        bottom=False,      # ticks along the bottom edge are off
        top=False,         # ticks along the top edge are off
        labelbottom=False) # labels along the bottom edge are off
        for level in self.energy_dict:
            degeneracy = len(self.energy_dict[level])
            x = np.arange(-(0.5*(degeneracy - 1)),(0.5*(degeneracy)), 1)
            y = [level]*(degeneracy)
            ax.scatter(x, y, s =900, marker = '_', linewidth = 3)
        plt.show()
    def __str__(self):
        string = 'Huckel Energies (degeneracy) for ' +self.smiles +':'
        for level in dict(sorted(self.energy_dict.items())): #this sorts the energy levels in order from lowest to highest
            degeneracy = len(self.energy_dict[level])
            string = string + " [%.3f (%d)] " % (level, degeneracy)
        return string
