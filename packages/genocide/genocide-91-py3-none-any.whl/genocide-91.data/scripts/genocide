#!python
# This file is placed in the Public Domain.
# pylint: disable=C0103,C0115,C0116,C0413,W0212,C0301,W0613,E0611,E0401


"@KarimKhanQC reconsider OTP-CR-117/19"


## imports


import atexit
import importlib
import importlib.util
import inspect
import os
import readline
import rlcompleter
import sys
import shutil
import time
import termios
import traceback


sys.path.insert(0, os.getcwd())


from genocide import Cfg, Command, Event, Handler, User, Wd
from genocide import Wd, cdir, edit, find, keys, last, printable, save, write
from genocide import elapsed, fntime, launch, match
from genocide import boot, command, scandir, scanpkg, wait


import genocide
import genocide.modules


## defines


Cfg.banner = "@KarimKhanQC reconsider OTP-CR-117/19"
Cfg.name = "genocide"
Cfg.version = "91"


Wd.workdir = os.path.expanduser("~/.genocide")


date = time.ctime(time.time()).replace("  ", " ")


## classes


class CLI(Handler):

    @staticmethod
    def announce(txt):
        pass

    @staticmethod
    def raw(txt):
        print(txt)
        sys.stdout.flush()


class Console(CLI):

    @staticmethod
    def handle(event):
        Command.handle(event)
        event.wait()

    def poll(self):
        event = Event()
        event.txt = input("> ")
        event.orig = repr(self)
        return event


## completer


class Completer(rlcompleter.Completer):

    def __init__(self, options):
        rlcompleter.Completer.__init__(self)
        self.matches = []
        self.options = options

    def complete(self, text, state):
        if state == 0:
            if text:
                self.matches = [
                                s for s in self.options
                                if s and s.startswith(text)
                               ]
            else:
                self.matches = self.options[:]
        try:
            return self.matches[state]
        except IndexError:
            return None


def setcompleter(optionlist):
    completer = Completer(optionlist)
    readline.set_completer(completer.complete)
    readline.parse_and_bind("tab: complete")
    atexit.register(lambda: readline.set_completer(None))


## utilities


def daemon():
    pid = os.fork()
    if pid != 0:
        os._exit(0)
    os.setsid()
    os.umask(0)
    sis = open("/dev/null", 'r')
    os.dup2(sis.fileno(), sys.stdin.fileno())
    if not Cfg.verbose:
        sos = open("/dev/null", 'a+')
        ses = open("/dev/null", 'a+')
        os.dup2(sos.fileno(), sys.stdout.fileno())
        os.dup2(ses.fileno(), sys.stderr.fileno())


def importer(mname, path=None):
    if path is None:
        spec = importlib.util.find_spec(mname)
    else:
        spec = importlib.util.spec_from_file_location(mname, path)
    if spec:
        mods = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mods)
        return mods
    return None


def initer(mname, path=None):
    mods = importer(mname, path)
    if mods and "init" in dir(mods):
        thr = launch(mods.init)
        thr.join()


def scan(mod):
    for key, cmd in inspect.getmembers(mod, inspect.isfunction):
        if key.startswith("cb"):
            continue
        names = cmd.__code__.co_varnames
        if "event" in names:
            Command.add(cmd)


def scanner(mname, path=None):
    mods = importer(mname, path)
    scan(mods)


def wrap(func):
    fds = sys.stdin.fileno()
    gotterm = True
    try:
        old = termios.tcgetattr(fds)
    except termios.error:
        gotterm = False
    try:
        func()
    except (EOFError, KeyboardInterrupt):
        print("")
    finally:
        if gotterm:
            termios.tcsetattr(fds, termios.TCSADRAIN, old)
        for evt in Command.errors:
            ex = evt.__exc__
            traceback.print_exception(type(ex), ex, ex.__traceback__)


## runtime


def main():
    boot(" ".join(sys.argv[1:]))
    if Cfg.daemon:
        daemon()
        Cfg.wait = True
    if Cfg.mod:
        scanpkg(genocide.modules, scanner, Cfg.mod)
        scanpkg(genocide.modules, initer, Cfg.mod)
    if Cfg.prs.txt:
        scanpkg(genocide.modules, scanner)
        cli = CLI()
        return command(cli, Cfg.prs.otxt)
    if Cfg.console:
        print("%s started at %s %s" % (
                                       Cfg.name.upper(),
                                       date,
                                       printable(
                                                 Cfg,
                                                 skip="banner,name",
                                                 plain=True)
                                                )
                                      )
        setcompleter(Command.cmd)
        cli = Console()
        launch(cli.start)
        Cfg.wait = True
    if Cfg.wait:
        wait()


wrap(main)
