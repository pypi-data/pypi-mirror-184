# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/ml/ml.evaluation.ipynb.

# %% auto 0
__all__ = ['find_binary_clf_threshold']

# %% ../../nbs/ml/ml.evaluation.ipynb 3
import numpy as np
from fastcore.basics import ifnone

# %% ../../nbs/ml/ml.evaluation.ipynb 4
def find_binary_clf_threshold(targets, preds, metrics, *, threshold_range=None, weight=None, metric_names=None, show=True):
    """Find the best threshold for binary classification given targets and predicted probabilities"""
    if weight is None:
        weight = [1.0] * len(metrics)
    if threshold_range is None:
        threshold_range = np.arange(0, 1, 0.05)
    weight = (np.array(weight) / np.sum(weight)).reshape(len(metrics), -1)
    scores = np.array([
        [metric(targets, preds > threshold) for threshold in threshold_range]
        for metric in metrics
    ])
    wavg_scores = (scores * weight).sum(axis=0)
    best_idx = wavg_scores.argmax()
    best_threshold =  threshold_range[best_idx]
    best_score =  wavg_scores[best_idx]

    if show:
        import matplotlib.pyplot as plt
        if metric_names is None:
            metric_names = [None]*len(metrics)
        metric_names = [
            ifnone(name, ifnone(getattr(metric, '__name__', None), f"Metric - {i}")) 
            for i, (metric, name) in enumerate(zip(metrics, metric_names))
        ]
        fig = plt.figure(figsize=(8, 4))
        plt.plot(threshold_range, scores.T, label=metric_names)
        plt.plot(threshold_range, wavg_scores.T, label='Weighted avg', linewidth=2)
        plt.plot([best_threshold], [best_score], 'ro')
        plt.axvline(x=best_threshold, color='gray', linestyle='--')
        plt.legend(loc='best')
        plt.show()
    
    return best_threshold
